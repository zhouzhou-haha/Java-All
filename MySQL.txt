书写规范：
	[]	表示可省略

MySQL基础：	
MySQL(关系型数据库):		关系型数据库：在关系模型基础上，由多张互相连接的二维表组成的数据库
	数据：数据库中存储的基本对象，描述事务的符号记录
	数据库DataBase(DB):存储和管理数据的仓库			
	数据库管理系统(DBMS):操作和管理数据库的大型软件
		         ------> table1
	     ------> DB1
	    	         ------> table2
		         ------> table1				数据模型：库/表
	DBMS ------> DB2
		         ------> table2
		         ------> table1	
	     ------> DB3	
                         ------> table2
			
		MySQL数据库服务器

	JDBC(Java DataBase Connectivity)：	使用Java语言操作关系型数据库的一套API	
		本质：Sun公司定义的一套操作所有关系型数据库的接口
		     各个数据库厂商实现这套接口，提供数据库驱动jar包
	
	数据库产品：	
		关系型数据库SQL:
			Oracle：大型公司，政府，银行使用	收费数据库(不差钱才会用)		通过SQL(统一标准)操作关系型数据库
			MySQL:	免费开源的中小型数据库	
			SQL Server：MicroSoft公司收费的中型数据库
			DB2：IBM公司的大型收费数据库
		
		非关系型数据库：
			MongoDB/Redis
	
	数据库图形化界面：navicat/Grapdict
	Idea内置数据库 -> database -> + -> Data Source -> MySql -> 数字 -> All schemas -> console -> DDL语言你 -> 绿色箭头运行		84节

	启动MySQL服务器：net start mysql80(MySQL服务名)
	停止MySQL服务器：net stop mysql80(MySQL服务名)
	登录：mysql -u root -p		输入密码
	退出：quit/exit			退出Mysql

	前提：MySQL不区分大小写
	     注释：单行注释	--或者#
		  多行注释	/* */
	
	数据类型：
		数值类型		
			int		带符号的整数			(-2^32,2^32-1)		4Byte
			tinyint 	范围较小的整数(存储布尔值/很小整数)	(-2^8,2^8-1)		1Byte	
			smallint 	范围较大的整数			(-2^16,2^16-1)		2Byte
			mediumint	中等大大的整数			(-2^24,2^24-1)		3Byte
			bigint		极大整数值			(-2^64,2^64-1)		8Byte
			integer		范围较大的整数						4Byte
			float		单精度浮点数						4Byte
			double		双精度浮点数						8Byte
		字符串类型
			char		定长字符串
			varchar		变长字符串
			text		长文本数据类型
			tinytext	短文本数据类型
			blob		二进制形式的长文本数据
			tinyblob	不超过255字符的二进制数据
		日期时间类型 
			date	 	年月日
			datetime 	年月日时分秒
			timestamp	时间戳		create_time:CURRENT_TIMESTAMP(默认)
			time	 	时分秒
			year		年份值				
		
	SQL：Structured Query Language	操作关系型数据库编程语言/结构化查询语言
		SQL语句分类：
			DDL	数据定义语言	定义数据库对象(数据库，表，字段)	Data Definition Language
			DML	数据操作语言	对数据库中的数据进行增删改操作	Data Manipulation Language
			DQL	数据查询语言	查询数据库表中的记录		Data Query Language
			DCL	数据控制语言	创建数据库用户，控制数据库访问权限	Data Control Language
		
	单表设计：	CRUD	增删改查的简写
		DDL(表操作):	alter
			数据库操作：
				create database [IF NOT EXISTS] 数据库名
					[CHARACTER SET 字符集]			指定字符集
					[COLLATE 排序规则];			指定排序规则
				use database db1；				选择使用的数据库
				drop database [if exists] db1;
				show create database(if not exists)数据库名；
				show databases；					查询所有数据库
				select database();				查询当前数据库
			
			表操作：
				创建表：		
					create table t_stu(
					s_id int primary key auto_increment comment 'id 唯一标识',	      
					s_name varchar(100) (约束/NOT NULL),
					s_class_name varchar(100) (约束),
					s_birthday date
					)engine InnoDB comment '用户表' [character set utf8mb4 collate utf8mb4_general_ci]；	comment + 注释

					表字段属性补充：
						auto_increment		定义自增长
						unSigned		无符号，该列不能为负数
						CHARACTER SET/CHARSET	指定字符集编码
、						collate			指定排序规则
						ENGINE			设置存储引擎，不指定设置为默认存储引擎InnoDB
						ZEROFILL		不足位数，0填充 例:int(3) 5-->  005
	
				删除表：			drop table [if exists] t_user;
				复制表：	 		create table 表名 as select 语句；
				删除指定表，重新创建该表：	trnncate table admin;
			
				查询：
					查询数据库所有表：show tables;
					查询表结构：desc t_user;
					查询指定表建表语句：show create table 表名;
			
			字段操作：
				修改：
					表的重命名:
						alter table t_stu rename to t_student;
						rename table t_user to t_student;

				添加：
					给t_student表添加字段 s_score double:
						alter table t_student add column s_score double;

					从已有的表中删除一列:
						alter table t_student drop column s_score;

					给已有表中的一列替换:
						alter table t_student change 旧列名 新列名 新类型

					把s_name重命名为s_stu_name:
						alter table t_student change s_name s_stu_name varchar(100);
						
					对已有的表添加外键：
						alter table 引用表 add constraint 约束名 foreign key(引用列) references 被引用表(被引用列);
					
					删除外键：
						alter table 表名 drop foreign key 外键名称；
			

		DML(数据操作)
			添加数据：	insert
				全表插入:	insert into 表名 values (每一列的值);
					例：insert into t_stu values(1, "stu1", "class1", "2000-01-01");

				缺省插入:insert into 表名(需要赋值的列) values(所有列的值);
					例：insert into t_stu(s_id, s_name) value (5, "stu5");

				批量添加数据：
					insert into t_stu values
						(6, "stu6", "class2", "2000-01-01"),
						(7, "stu7", "class2", "2000-01-01"),
						(8, "stu8", "class2", "2000-01-01");	
	
			修改数据：	update		
				update 表名 set 列名=新值, 列名=新值,…. where 约束条件
				例：将tb_patent_detail表中所有没有名字的学生名字设置为'no name'
				update
					tb_patent_detail
						set
							name = "no name",age = "no age"
						where
							name is null;

			删除数据：	delete	
				delete from 表 where 约束条件;
				delete from t_stu where s_id = 1; 

			清空数据(DDL):	trunctae
				truncate table 表名		
	
				delete/truncate区别：
					delete			truncate
					条件删除			删除整张表
					不影响自增		重新设置自增
					DML语言，支持回滚		DDL语言，不支持回滚
						

		DQL(数据查询)		select
			全表查询：select * from t_stu;
				注意：实际开发中很少写*，写具体字段来查全表

			基础查询：select name as 姓名，age as 年龄 from t_user;		as 设置别名
				select distinct * from t_stu;		
					注意：distinct去除重复数据	
				
			条件查询：select 字段列表 from 表名 where 条件列表；
				运算符：
					算术运算符
					比较运算符
					逻辑运算符
					位运算符
			
					算术运算符：
						+	加法
						-	减法
						*	乘法
						/(div)	除法
						%(mod)	取余

					比较运算符：				
						>	大于				
						<	小于				
						>=	大于等于				
						<=	小于等于				
						=	等于				
						<>/!=	不等于
						范围：		(not)between...and.../(not)in(枚举值)
						模糊匹配		like		_表示单个字符，%表示任意字符	
						正则匹配		RLIKE/REGEXP

					逻辑运算符：
						与	and	&&
						或	or	||
						非	not	!

					NULL值运算符：	
						is null		当前列的值是NULL，返回true	
						is not null	当前列的值不为NULL，返回true
						<=> 		比较运算符，比较的值相等或者都为NULL返回true
					
						NULL相关函数：
							COALESCE(expression,Param1...0)	可接收多个参数，返回包括expression在内的所有参数的第一个非空值				
							IFNULL(Param1,0)		如果第一个参数为NULL，返回第二个参数0
		
			分组查询 + 聚合函数：
				聚合函数一般和查询字段一起使用		
				聚合函数：	将一列数据作为一个整体，进行纵向运算，不计算null
					count	统计数量	
						count(字段/*/常量)
					max	最大值
					min	最小值
					avg	平均值
					sum	求和

				分组查询：   group by	having分组过滤	查分组字段，聚合函数
					select 分组字段/聚合函数 from 表名 (where 条件) group by 分组字段(字段值相同) (having 分组后过滤条件)

					根据性别分组，统计男性和女性员工的数量	/男生一组，女生一组
					select gender，count(*) from tb_emp group by gender having count(*) >= 2;
					
					where/having区别：
						where是分组之前进行过滤；having对分组之后结果进行过滤
						where不能对聚合函数进行判断，having可以

			排序查询：	order by	指定一列或几列按照数据大小进行从小到大/从大到小的排序
				升序	asc
				降序	desc
				select 字段列表 from 表名 [where 条件列表][group by 分组字段] order by 字段 排序方式；
													
				排序方式：
					order by 字段1 排序方式 ，字段2 排序方式；
					order by 数字 排序方式 ，数字 排序方式；		数字表示列的位置
					order by 表达式 排序方式；	
					
				根据入职时间对公司的员工进行升序排序，入职时间相同，再按照更新时间进行降序排序
				select * from tb_emp order by entrydate asc,update_time desc;			多字段排序，第一个字段值相同时，才会根据第二个字段进行排序
					
				补充：NULLS LAST/NULLS FIRST		NULL值排在最后/最前
					例：order by price desc nulls last	
			
			分页查询：	limit	limit关键字一定是出现在最后一个
				select 字段列表 from 表名 limit 起始索引，查询记录数	
										
				从指定的索引开始，返回指定数量的数据记录			补充：一般指定降序顺序
				select * from tb_emp limit 0，5/limit 5；	简写
				
				页数：		起始索引 + 1
				起始索引：	(页数 - 1) * 每页记录数据

			*****	DQL执行顺序： from 表
						↓
					    where 条件
					 	↓
					    group by + having
						↓
					    select 字段
						↓
					    order by 排序字段
						↓
					    limit 分页参数


		DCL(数据控制)		运维管理数据库用户，控制数据库访问权限					
			用户管理：
				创建用户(当前主机访问)：create user '用户名'@'主机名' identified by '密码'；		补充：创建的用户没有权限
				创建用户(任意主机访问)：create user '用户名'@'%' identified by '密码';
			
				删除用户(任意主机访问)：drop user '用户名'@'主机名'；
			
				修改用户密码：alter user 用户名@主机名 identified with mysql_native_password by '密码'；
			
				查询用户：select * from user；

				修改用户名：rename user '用户名' to  '新用户名'

			数据库常用权限：
				ALL/ALL PRIVLEGES	所有权限
				SELECT			查询数据
				INSERT			插入数据
				UPDATE			修改数据
				DELETE			删除数据
				ALTER			修改表
				DROP 			删除数据库/表/视图
				CREATE			创建数据库/表
				INDEX			创建和删除索引
				GRANT OPTION		将自己拥有的权限授予其他用户
				EXECUTE			执行存储过程和函数
				LOCK TABLES		锁定表进行并发控制
			
			权限控制：
				查询权限：show grants for '用户名'@'主机名'					通配符：*		表示所有
			
				授予权限：grant 权限列表 on 数据库名.表名 to '用户名'@'主机名'
					grant all on *.* to '用户名'@'主机名'

				撤销权限：revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'
					revoke all on *.* from '用户名'@'主机名'

	多表设计：			
		表结构关系：
			一对一	1:1
			一对多	1:n
			多对多	n:n
			
			一对一：	
				多用于单表拆分，将一张表的基础字段放在一张表中
				实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一(Unique实现一对一),

			一对多：
				实现：在数据库表中多方添加字段建立外键，关联一方主键
				外键约束保证数据的一致性和完整性
					创建表时指定外键：
						[constranint] [外键名称] foreign key(外键字段名) references 主表(字段名)
					对已有的表添加外键：
						alter table 引用表 add constraint 约束名 foreign key(引用列) references 被引用表(被引用列);
					
				注意：上面添加的物理外键，在实际开发中用的很少/禁用，一般使用逻辑外键

				多表查询关联关系(一对多)：
				实体类：		User类与Account类存在关联关系
				    User类：
					public class User implements Serializable{
						private Integer id;
						private String name;
						private List<Account> accounts;
					}
				    Account类：
					public class Account implements Serializable{
						private Integer id;
						private Integer uid;
						private Double money;
						private User user;
					}
				
				接口方法：
					UserMapper：
						List<User> findAll();
						User findById(Integer id);
					AcountMapper：
						List<Account> findAll();
						Account findById(Integer id);
									
				XML映射文件： 
					<resultMap id = "patentMap" type = "com.zxhc.technologicalproject.vo.TeAndRePatentVO">
        						<id column="id" property="id"/>
        						<result column="project_guid" property="projectGuid"/>				这里column是表查出来的字段名(注：可以是别名)
        						<result column="personalPatentGuid" property="personalPatentGuid"/>
       						 	<result column="distinguish" property="distinguish"/>
        						<result column="documentCategory" property="documentCategory"/>
        						<collection property="patentFileVOList" ofType="com.zxhc.technologicalproject.vo.file.FileVO">
            							<id column="id" property="fileId"/>
            							<result column="file_guid" property="fileGuid"/>
            							<result column="file_original_name" property="fileOriginalName"/>
            							<result column="file_extension" property="fileExtension"/>
        						</collection>
    					</resultMap>		
					<select id = "selectByPid" reaultType = "User">						注意：这里resultType的类型是上面resultMap的别名
						select * from User where uid = #{id}		自关联查询
					</select>
					注:
					    property --> Java属性字段
					    column -->  一般:数据库表字段
						   --> 特殊:关联查询需要传入的值
					    ofType --> 返回结果类型	
					    select --> 查询语句
					补充：
						自关联查询：同一张表的不同属性产生的关联				
						外键关联查询：不同表当中的属性产生的关联
					
			多对多：
				实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键

				学生表(student)		学生课程关系表(student_course)		课程表(course)
				student_id	←	student_id				
							course_id		→		course_id
							中间表

		多表查询(DQL)：从多张表中查询数据		查出的数据是两张表的笛卡尔积
				笛卡尔积：在数学中，两个集合的所有组合情况
			select
				c.c_id, c_name, c_loc, e_id, e_name, e_job, e_money, e.c_id  --所有列
			from
				t_company c,  t_emp e    	--所有表
			where
				c.c_id = e.c_id; 		两张表的关联id消除无效笛卡尔积
				
			连接查询：	不会产生多表查询生成的无效笛卡尔积
				join	在一定的条件下将两张表连接成一张伪表，再对这张表进行查询

				内连接：查询两张表A,B交集部分数据(A∩B)
					等值连接：在关键字on后的匹配条件通过=实现，通常是一张表连接另外一张表
						简单/双表INNER JOIN：
							select * from t_employee e inner join t_dept d on e.deptno = d.deptno;
						多表INNER JOIN:		
							SELECT orders.order_id, customers.customer_name, products.product_name
							FROM orders
							INNER JOIN customers ON orders.customer_id = customers.customer_id
							INNER JOIN order_items ON orders.order_id = order_items.order_id
							INNER JOIN products ON order_items.product_id = products.product_id;							

					非等值连接：在关键字on后使用除了=以外的关系运算符实现的不等条件(> >= < <= !=)
						select e.empno,e.ename,e.MGR,m.ename,m.empno
         					from t_employee e inner join t_employee m
         					on e.MGR = m.empno and e.empno > m.empno;
                        
					自连接：内连接查询中特殊的等值连接。表与自己当前表进行连接

					隐式内连接：
						select 字段列表 from 表1，表2 where 条件；(实际开发偏多)
					显示内连接：
						select 字段列表 from 表1 inner join 表2 on 连接条件；

				外连接(实际开发)：
					简单左外连接：获取左表所有记录，即使右表没有对应匹配字段，where条件消除无效笛卡尔积
						select 字段列表 from 表1 left [outer] join 表2 on 连接条件；
						例：select e.name,d.name from tb_emp e left join tb_dept d on e.dept_id = d.id where 筛选条件;
						
					多表左外连接：	
						select a.customer_id, a.customer_name, b.order_id, products.product_name
						from customers a
							left join   orders b on a.customer_id  =  b.customer_id
							left join order_items  c on b.order_id =  c.order_id
							left join  products d on c.product_id = d.product_id;
						where b.order_date >= '2023-01-01' or  b.order_id  is null;					

					右外连接：获取右表所有记录，即使左表没有对应匹配字段，where条件消除无效笛卡尔积
						select 字段列表 from 表1 right [outer] join 表2 on 连接条件；
						例：select e.name,d.name from tb_emp e right join tb_dept d on e.dept_id = d.id where 筛选条件;

				注意：1.where是表中数据筛选条件，on是两张表关联条件
				     2.在进行内连接/外连接，关联字段并不会合并为一个字段，两张表的重复字段都是以字段(一)，字段(二)的形式存在
					
			子查询(嵌套查询)：		
				SQL语句中嵌套的select语句，称为子查询
				分类：
					标量子查询	子查询返回的结果为单个值(单行单列)
						常用操作符：>  <  >=  <=  <> != = 

						select * from tb_emp where dept_id  = (select * from tb_dept where name = '教研部'/id = 2);

					列子查询		子查询返回的结果为一列(多行单列)
						常用操作符：IN/NOT IN/ANY/SOME/ALL
							ALL		子查询列表的所有值都必须满足
							ANY/SOME	子查询列表的值有任意一个满足

						select * from tb_emp where entrydate > all (select entrydate from tb_emp where name = '周舟')；

					行子查询		子查询返回的结果为一行(单行多列)
						常用操作符：= <> IN/NOT IN
	
						select entrydate,job from tb_emp where name = "韦一笑"
						select * from tb_emp where entrydate = '2007-01-01' and job = 2; 	优化：select * from tb_emp where(entrydate,job) = ('2007-01-01',2); 
						
						行子查询：select * from tb_emp where (entrydate,job) = (select entrydate,job from tb_emp where name = "韦一笑")；
						
 					表子查询		子查询返回的结果为多行多列(多行多列)
						常用操作符：IN

						select * from tb_emp where entrydate > '2006-01-01';
						select e.*,d.name from(select * from tb_emp where entrydate > '2006-01-01') e,tb_dept d where e.dept_id = d.id;

			联合查询(union/union all)：
				UNION关键字：用于连接将两个以上的select语句的结果组合到一个结果合集，去除重复的行
				UNION ALL：用于连接将两个以上的select语句的结果组合到一个结果合集，不去除重复的行
				
				注意：必须有相同字段，相似数据类型的表才能使用UNION/UNION ALL联合查询
					
	约束：作用于表中字段上的规则，用于限制存储在表中的数据
		主键约束：唯一且非空(数值主键自增长)			primary key，auto_increment		主键约束 = 唯一约束 + 非空约束
		唯一约束：字段数据唯一不重复				unique
		非空约束：字段值不能为null  			not null
		外键约束：两张表建立连接，保证数据一致			foreign key
		默认约束：保存数据，未指定该字段值，采用默认值		default	
		检查约束：保证列中的值满足某一条件			check
			注：mysql不支持检查约束

		使用约束创建表：
			create table t_stu(
				s_id int primary key auto_increment comment 'id 唯一标识',	      
				s_name varchar(100) not null unique comment '姓名',
				s_class_name varchar(100) not null unique comment '班级名称',
				s_birthday date check(date >= '2001-01-01' and date <= '2024-12-25'),
				s_status char(1) default '1' comment '状态'
				[constranint class_id] foreign key class_id references t_class(id);
			)comment '用户表' [character set utf8mb4 collate utf8mb4_general_ci]；	comment + 注释

		添加外键：
			创建表时指定外键：[constranint] [外键名称] foreign key(外键字段名) references 主表(字段名)
			实际开发：[constranint class_id] foreign key class_id references t_class(id);	
				
			对已有的表添加外键：alter table 引用表 add constraint 外键名 foreign key(引用列) references 被引用表(被引用列);
			实际开发：alter table t_user add constraint class_id foreign key (class_id) references t_class(id); 

		外键级联操作：
			NO ACTION	在父表中删除/更新对应记录时，检查该记录是否有对应外键，如果有不允许删除/更新
			RESTRICT	在父表中删除/更新对应记录时，检查该记录是否有对应外键，如果有不允许删除/更新
			CASCADE		在父表中删除/更新对应记录时，检查该记录是否有对应外键，如果有，删除/更新外键在子表中的记录
			SET NULL	在父设置表中删除对应记录时，检查该记录是否有对应外键，如果有，设置子表中外键值为null
			SET DEFAULT	父表有更新时，子表外键设置成默认值(Innodb不支持)
				注意：父表 -> 引用表
			
			添加外键指定删除/更新行为：
				alter table t_user add constraint class_id foreign key (class_id) references t_class(id) on delete cascade on update cascade;
			
		
	函数：		一段可以直接被另一段程序调用的程序或代码
		所有函数：
			见函数大全			

		补充：
			BIN(x)				返回x的二进制编码，x是十进制数
			BINARY(s)			将字符串s转换为二进制字符串	
			CAST(x AS type)			将一个类型转换成另一个类型
		
		流程函数：
			if(表达式，value1，value2)：				当表达式为true时，取值为value1；当表达式为false时，取值为value2
			ifnull(value1,value2)					如果value1不为空，返回value1，否则，返回value2

			case 表达式  
				when 值1 
					then 结果1 
				when 值2 
					then 结果2 
				else 默认值 			
					end					如果表达式值为下列值之一，返回对应返回值，否则返回默认值

			流程函数实际开发举例：
				if(表达式，value1，value2)：
					select if(false,'OK','Error');
				
				ifnull(value1,value2)：	
					select ifnull('Ok','Default');

				case 表达式 when 值1 then 结果1 when 值2 then 结果2 else 默认值 end：
					SELECT
            				    	CASE
                					WHEN b.device_level=1 
								THEN (SELECT line_name FROM main_line WHERE id = b.device_id)
               	 					WHEN b.device_level>1 
								THEN (SELECT tower_name FROM main_tower WHERE id=b.device_id)
                					END AS device_name
        				FROM
            					main_airspace_device_type a


	事务：是一组操作的集合，管理insert，update，delete语句。事务将所有命令操作作为整体向系统提交或撤销操作请求，要么同时成功，要么同时失败
		Mysql只有使用Innodb数据库引擎的数据库/表才能支持事务
		例：	create table if not exists student(
				id int(4) not null primary key auto_increment comment '学号',
				name varchar(30) not null default '匿名' comment '姓名',
				pwd varchar(20) not null default '123456' comment '密码'，
				sex varchar(2) not null default '女' comment '性别'，
				birthday default default null comment '出生日期',
				address varchar(100) default null comment '家庭住址',
				email varchar(50) default null comment '邮箱',
				index idx_name (name)					创建索引
			)engine = Innodb default charset = utf8;
						
		Mysql事务是自动提交的，当执行一条DML语句(delete语句)，MySQL立即隐式提交事务

		事务控制：
			设置Mysql事务自动提交模式：
				set autocommit = 0	禁止自动提交
				set sutocommit = 1	开启手动提交			

			手动开启事务		start transaction;/begin;
			手动提交事务		commit;
			手动回滚事务		rollback;	事务出现错误才添加回滚(将临时修改的数据恢复回去)	

			自动提交：	set autocommit = 1
				start transction;/begin;		开启事务
				delete from tb_dept where id = 2；	删除部门			开启事务，保持删除业务数据一致
				delete from tb_emp where dept_id = 2;	输出部门下员工
				commit;/commit work;			提交事务			业务正常执行提交到数据库
				rollback;/rollback work;		回滚事务			业务出现异常回滚事务

		事务四大特性(ACID)：
			原子性/Atomicity		事务是不可分割的最小单位，要么全部成功，要么全部失败
			一致性/Consistency	事务完成时，所有数据都保持一致
			隔离性/Isolatio		数据库系统提供的隔离机制，保证事务在独立环境下运行
			持久性/Durability	事务一旦提交或回滚，对数据库中数据改变就是永久的，数据持久化到硬盘

		并发事务问题：
			脏读：一个事务读取到另一个事务未提交的数据，导致读出数据与存储数据不一致
			幻读：一个事务按照条件查询数据时候，没有对应数据行，但是插入数据时，发现这条数据已经存在
			更新丢失：并发事务环境中，由于两个或多个事务同时读取并修改相同数据，导致某些更新被覆盖或丢失
			不可重复读：一个事务先后读取同一条记录，两次读取的数据不同
				
			脏数据：计算机系统中出现的不一致或者不准确的数据，数据可能已经过时，失效，损坏或者未经验证。脏数据可能导致系统出现错误的结果或者不正确的行为
		
		事务隔离级别(解决并发事务问题)：
			隔离级别：	READ-UNCOMMITTED	读未提交
					READ-COMMITTED		读已提交
					REPEATABLE-READ		可重复读
					SERIALIZABLE		串行
	
					脏读		不可重复读		幻读		更新丢失
			读未提交：	 ✔		   ✔			 ✔		  ✔
			读已提交：	 ×		   ✔			 ✔		  ✔			✔：不能解决
			可重复读：	 ×		   ×			 ✔		  ✔			×：可以解决
			串行：		 ×		   ×			 ×		  ×
			
			查看隔离级别：select @@ TRANSACTION_ISOLATION;
			设置事务隔离级别：transaction-isolation = READ-UNCOMMITTED(隔离级别)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MySQL进阶：	
	MySQL体系结构：
		连接层		负责与客户端的连接，负责用户认证授权，管理用户权限和访问控制
		服务层		提供SQL解析(解析器)，查询优化(优化器)，执行计划的生成(执行引擎)，处理事务管理和存储过程的调用(事务管理)
		引擎层		根据不同的存储引擎负责数据的存储和提取，服务器通过API和存储引擎进行通信
		存储层		实际数据的存储和管理，将数据以文件形式存储在磁盘上，包括数据文件和日志文件
			注意：不同的存储引擎，索引结构是不同的
	
	数据库存储引擎(引擎层)：			存储引擎：基于表存储数据，建立索引，更新、查询数据等技术的实现方式								表空间文件：
		InnoDB(默认)		支持事务，行级锁，外键约束和MVCC(多版本并发控制)		表名.ibd(存储表结构，数据和索引)
		MyISAM(早期默认)		不支持事务，表级锁，数据压缩节省空间，访问速度快		xxx.sdi(存储表结构)/xxx.MYD(存储数据)/xxx.MYI(存储索引)
		Memory			不支持事务，表级锁，数据存储在内存中，用作临时表		xxx.sdi(存储表结构信息)

		创建表时指定存储引擎：
			create table 表名{	
				字段1 字段1类型 [comment 字段1注释]，
				字段n 字段n类型 [comment 字段n注释]，
			}engine = InnoDB [comment 表注释]；
		
		查询当前数据库支持存储引擎：show engines；
			
		选择存储引擎：
		(目前主流，默认)	InnoDB	->	支持事务，外键，查询操作除插入和查询之外，包括更新，删除操作
		(被MongoDB取代)	MyISAM	->	系统以select和insert为主，只有很少的update和delete操作，对事务完整性和并发性要求不高
		(被Redis取代)	Memory	->	将所有数据保存在内存中，通常用于临时表和缓存


	InnoDB存储引擎：		MySQL5.5版本开始，默认使用InnoDB存储引擎
		逻辑存储结构：
			  表空间		  段		  区		 页		 行
									page		Row(Trx id)
							Extent	  →		→
					Segment	  →			page		Row(Roll pointer)
			Tablespace  →			Extent	  →		→
					Segment	  →			page		Row
							Extent    →		→
									page		Row
			
				表空间(Tablespace)：一个MySQL示例对应多个表空间，用存储记录，索引等数据
				段(Segment)：存储不同类型的数据和索引结构
					数据段：存储实际表数据的区域，数据段是B+树叶子节点
					索引段：存储表的索引数据的区域，索引段是B+树非叶子节点
					回滚段：存储事务回滚信息的区域，InnoDB将数据修改前的旧值保存到回滚段中
				区(Extent)：64个连续的16KB页组成的存储块。保证页连续性，InnoDB存储引擎从磁盘申请4-5个区			补充：1区 = 64 × 16KB页	
				页(Page)：InnoDB存储引擎的最小单元，页默认大小为16KB
				行(Row)：InnoDB存储数据的最小单位，表示表中一条数据记录							补充：在物理引擎上，行数据以二进制格式存储
				
				行隐藏字段(补充)：
					Trx_id：记录最后一次修改某行数据的事务ID，主要用于实现事务隔离性和多版本并发控制(MVCC)
					Roll_pointer：指向该行数据的Undo Log(修改之前的记录)，支持事务回滚和恢复和实现多版本并发控制(MVCC)

		架构：
			InnoDB引擎架构示意图：
					内存结构					磁盘结构
					Buffer Pool(缓冲池)			System Tablespace(系统表空间)
												
					Change Buffer(更改缓冲区)			File-Per-Table Tablespces(独立表空间)
							
					Adaptive Hash Index(自适应哈希索引)	General Tablespaces(通用表空间)
				
					Log Buffer(日志缓冲区)			Undo Tablespaces(回滚表空间)
				
										Temporary Tablespaces(临时表空间)
										
										Doublewrite Buffer Files(双写缓冲区文件)
					
										Redo Log(重做日志)

			内存结构：
				缓冲池(Buffer Pool)：
					作用：存磁盘上经常操作的数据，执行增删改查操作时，先操作缓冲池中数据(若缓冲池没有数据从磁盘加载并缓存)再以一定频率刷新到磁盘，减少磁盘IO
					
					缓冲池组成：
						数据页：存储表中实际数据行
							Free Page：未被使用的空闲数据页
							Clean Page：数据被使用，数据与缓存中的数据一致
							Dirty Page：数据被使用，数据与缓存中的数据不一致
						索引页：存储表的索引信息
						双写缓冲：InnoDB使用双写缓冲区将数据线写入内存中双写缓冲区再写入磁盘

				更改缓冲区(Change Buffer)：
					原因：二级索引数据不连续性，修改二级索引时需要进行频繁磁盘IO消耗性能
					
					作用：	执行DML(insert/update/delete)操作二级索引页时，若数据Page没有在缓冲池中，不会直接操作磁盘。
						将数据存在Change Buffer中，在未来读取数据时将Change Buffer中数据合并恢复到缓冲池中，再将合并数据刷新到磁盘，减少磁盘IO

				自适应哈希索引(Adaptive Hash Index)：
					作用：优化对Buffer Pool缓冲池数据(热点数据)查询，InnoDB引擎监控对表上各索引页查询，动态构建哈希索引提升数据访问速度

					补充：自适应哈希索引无需人工干预，MySQL根据情况自动完成
						
					查看自适应哈希索引开关是否开启：
						show variables like 'innodb_adaptive_hash_index';
						结果：innodb_adaptive_hash_index		ON
				
				日志缓冲区(Log Buffer)：
					作用：保存写入到磁盘中的log日志数据(redo log:重做日志/undo log:回滚日志) ，InnoDB会将日志定期刷新到磁盘中，即使系统崩溃也可以通过日志恢复
							
					查看缓冲区大小：		show variables like 'innodb_log_buffer_size'		
						结果：		innodb_log_buffer_size			16777216

					查看日志刷新到磁盘时机：	show varibales like 'innodb_flush_log_at_trx_commit'	
						结果：		innodb_flush_log_at_trx_commit		1		
							
							1：日志在每次事务提交时写入并刷新磁盘
							0：每秒将日志写入并刷新到磁盘
							2：日志在每次事务提交后写入并刷新到磁盘
		

			磁盘结构：
				系统表空间(System Tablespace)：
					作用：存储InnoDB必需的全局数据、元数据、双写缓冲、回滚日志等		
						数据字典：存储InnoDB表的元数据(表结构、索引信息等)
						Undo Log：事务回滚，确保数据库恢复到事务开始之前的状态
						双写缓冲区：防止数据页在写入磁盘时发生部分写入的情况，确保数据一致性
						InnoDB内部管理信息：表空间信息、事务日志等

					查看系统表空间对应文件：show variables like 'innodb_data_file_path'			结果：ibdata1:12M:autoextend
									
				独立表空间(File-Per-Table Tablespaces)：
					作用：InnoDB为每个表创建一个独立的表空间(.ibd文件),用户表数据和索引存储在每张表对应的独立文件中
						
					查看独立表空间文件是否开启：show variables like 'innodb_file_per_table';		结果：ON(默认开启)

				通用表空间(General Tablespaces):
					作用：将多个表和索引存储在同一个表空间文件中，不为每个表都创建单独的.ibd文件

					创建表空间语法：
						create tablespace xxx add datafile 'filename' engine = engine_name;

					演示：
						创建表空间：create tablespace ts1 add datafile 'share.ibd' engine = InnoDB;
						
						创建表指定表空间：
							create table employees(
								id int primary key,
								name varchar(100)	
							)tablespace ts1;			
							
				回滚表空间(Undo Tablespaces)：
					作用：InnoDB存储回滚事务Undo Log，确保数据库恢复到事务开始之前的状态

					Undo Log：在事务未提交前，撤销对数据库的更改
				
				临时表空间(Temporary Tablespaces)：
					作用：InnoDB将临时表数据存储在临时表空间

					查看临时表空间对应文件：show variables like 'innodb__temp_data_file_path';		结果：ibtmp1:12M:autoextend
					
				双写缓冲区文件(Doublewrite Buffer Files)：
					作用：innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件。便于系统故障时恢复丢失数据页
				
					查看是否启用双写缓冲区：	show variables like 'innodb_doublewrite'
						结果：		innodb_doublewrite 			1
					
					查看日志刷新到磁盘时机：	show variables like 'innodb_flush_log_at_trx_commit';
						结果：		innodb_flush_log_at_trx_commit		1
							
							1：日志在每次事务提交时写入并刷新磁盘
							0：每秒将日志写入并刷新到磁盘
							2：日志在每次事务提交后写入并刷新到磁盘				

				重做日志(Redo Log)：帮助数据库奔溃后恢复重做已提交的事务，确保数据不会因为系统故障丢失


			后台线程：
				作用：将InnoDB缓冲池中数据在合适时机刷新到磁盘中

				主要后台线程分类：
					Master Thread(主线程)：InnoDB总控线程，负责协调其他线程，缓冲池脏页刷新，合并插入缓存变更，undo页回收
					IO Thread(I/O线程)：InnoDB大量使用AIO处理所有与磁盘I/O操作，将数据从磁盘读取到内存，或将内存中脏页刷写到磁盘
					Purge Thread(清理线程)：回收已经提交事务不再使用的Undo Log日志文件
					Page Cleaner Thread(页面清理线程)：协助主线程Master Thread刷新脏页到磁盘，减少主线程压力

				操作：
					查看读I/O线程数：show varibales like 'innodb_read_io_threads'
					查看写I/O线程数：show varibales like 'innodb_write_io_threads'
					查看Purger线程数：show variables like 'innodb_purge_threads';
					查看Page Cleaner线程数：show variables like 'innodb_page_cleaners';
					
		事务原理：
			事务四大特性(ACID)：
				原子性/Atomicity		事务是不可分割的最小单位，要么全部成功，要么全部失败
				一致性/Consistency	事务完成时，所有数据都保持一致
				隔离性/Isolatio		数据库系统提供的隔离机制，保证事务在独立环境下运行
				持久性/Durability	事务一旦提交或回滚，对数据库中数据改变就是永久的，数据持久化到硬盘

			Redo Log/Undo Log：	保证原子性/一致性/持久性
				Redo Log(重做日志)：事务提交后将所有修改信息存储到日志文件，系统故障时进行数据恢复			补充：Redo Log是物理日志
					redo  log buffer(重做日志缓冲文件)		内存
					redo log file(重做日志文件)		磁盘			
					
				Undo Log(回滚日志)：记录数据被修改前的信息，支持回滚和MVCC(多版本并发控制)			补充：Undo Log是逻辑日志
					回滚：执行rollback时，可以从undo log中的逻辑记录读取到相应内容进行回滚

			MVCC/锁：		保证隔离性			主要介绍MVCC，锁在下方讲解
						
				
			
	
	
	索引：		
		概念：MySQL的一种数据结构，用于加快数据库查询的速度和性能
		索引优缺点：
			优点：	直接定位到满足查询条件的数据行，提高数据查询速度
				通过索引列对数据进行排序，降低CPU消耗

			缺点：	索引需要额外的存储空间				补充：实际开发缺点几乎可以忽略(1.现在市面上磁盘很便宜/2.对系统来说，增删改所占比例很小)
				进行insert，update，delete操作时，性能下降

		索引底层数据结构：		引擎层实现MySQL索引,不同的存储引擎有不同的结构
						InnoDB			MyISAM			Memory
			B-TREE(B树索引)		支持			支持			不支持		
			B+TREE(B+树索引)		支持			支持			支持		
			HASH(哈希索引)		不支持			不支持			支持
			R-tree(空间索引)		不支持			支持			不支持
			Full-text(全文索引)	5.6之后支持		支持			不支持
			
			注意：	MySQL索引结构主要研究InnoDB索引的B+树索引结构

		MySQL索引底层原理：	以空间换时间
			B+树	哈希索引				关于B+树与哈希索引详解在数据结构与算法中查看			
				
		索引分类：		
			主键索引(Primary Key Index)：针对表中主键创建的索引，每个表只能有一个主键索引			添加主键约束自动创建主键索引
			唯一索引(Unique Index)：避免同一表中某数据列中的值重复，一个表可以有多个唯一索引			添加唯一约束自动创建唯一索引
			常规索引：
				单列索引(Regular Index)：一个索引包含单个列，一个表可以有多个单列索引	
				组合索引/联合索引(Composite Index)：一个索引包含多个列，一个表可以有多个多列索引
			全文索引(Full-text Index)：查找文本中的关键词，对文本内容进行快速搜索

			聚集索引(Clustered Index)：索引结构(B+树)的叶子结点保存行数据，表中只能有一个聚集索引
			非聚集索引/二级索引(Secondary Index)：索引结构(B+树)的叶子结点保存对应主键ID，一个表中可以有多个非聚集索引

			注意：	如果存在主键，主键索引就是聚集索引
				如果不存在主键，使用第一个唯一(UNIQUE)索引作为聚集索引
				如果不存在主键/合适的聚集索引，则InnoDB自动生成一个rowid作为隐藏的聚集索引
		
		思考题：
			判断下列SL语句哪个执行效率高，为什么？
				select * from user where id = 10；		id为主键
				select * from user where name = 'Arm'；		name字段创建索引

				查询id = 10，直接在聚集索引结构中查询叶子结点为10的数据
			回表查询	查询name = Arm，先在二级索引结构中查询结点为Arm对应的ID，再到聚集索引结构中查询叶子结点为ID的数据
			
		普通索引：	
			创建索引：
				CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (column1 [asc|desc],column2 [asc|desc],...);
		
				[UNIQUE|FULLTEXT]		创建唯一索引|全文索引	
				INDEX				用于创建普通索引的关键字
				index_name			要创建的索引的名称
				table_name			指定表上创建索引
				(column1,column2,...)		指定要索引的表列名。指定一个 单列索引/指定多个 组合索引

				例:有一个students的表，包含id，name和age列，在name列上创建一个普通索引
			   	   	CREATE INDEX idx_name ON students (name);
		
			添加索引(修改表结构)：		在已有的表创建索引
				ALTER TABLE table_name ADD INDEX index_name (column1 [asc|desc],column2 [asc|desc]);

				ALTER TABLE			用于修改表结构的关键字
				table_name			指定要修改的表名称
				ADD INDEX			创建普通索引的关键字
				index_name			创建的索引名称
				(column1,column2,...)		指定要索引的表列名。指定一个 单列索引/指定多个 组合索引
			
				例:在已存在的employees的表上创建一个普通索引	
			   	   	ALTER TABLE employees ADD INDEX idx_age (age);

			创建表指定索引：
				1.CREATE TABLE table_name (
  					column1 data_type,
  					column2 data_type,
  					...,
  					INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...)
			  	  );
					
				2.Navicat指定索引：
					右键点击设计表 -> 选择索引 -> 点击添加索引 -> 添加索引名称/索引字段/索引类型/索引方法
			
			删除索引：
				DROP INDEX index_name ON table_name;
				ALTER TABLE table_name DROP INDEX index_name;

			查看索引：
				show index from table_name\G		\G格式化输出信息	
			
		唯一索引：	
			创建索引：
				CREATE UNIQUE INDEX index_name ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);
			
				CREATE UNIQUE INDEX		用于创建唯一索引的关键字组合
				index_name			指定创建唯一索引的名字
				table_name			在哪个表上创建唯一索引
				(column1,column2,...)		指定要索引的表列名。指定一个 单列索引/指定多个 组合索引	
			
			添加索引(修改表结构)：
				ALTER table mytable ADD CONSTRAINT unique_constraint_name UNIQUE (column1, column2, ...);

				ALTER TABLE			用于修改表结构的关键字
				CONSTRAINT			用于添加约束的关键字
				ADD CONSTRAINT			这是用于添加约束（包括唯一索引）的关键字
				unique_constraint_name		指定要创建的唯一索引的名称，约束名称在表中必须是唯一的
				UNIQUE (column1, column2, ...)	指定要索引的表列名

			创建表指定唯一索引：
				CREATE TABLE table_name (
  					column1 data_type,
  					column2 data_type,
  					...,
  					CONSTRAINT index_name UNIQUE (column1 [ASC|DESC], column2 [ASC|DESC], ...)
				);

				CONSTRAINT	用于添加约束的关键字

			防止表中出现重复数据：
				例：设置表中字段first_name,last_name数据不能重复
				方法一：
					插入数据使用insert ignore into如果数据库没有数据就插入新的数据，有数据的话就跳过这条数据
				方法二：
					对字段设置唯一索引UNIQUE INDEX
					CREATE TABLE person_tbl(
   						first_name CHAR(20) NOT NULL,
   						last_name CHAR(20) NOT NULL,
   						sex CHAR(10),
   						UNIQUE (last_name, first_name)
					);

			删除索引：
				DROP INDEX index_name ON table_name;
				ALTER TABLE table_name DROP INDEX index_name;


	SQL性能分析工具：
		SQL执行频率：
			show  global status like 'Com_______';				查询当前数据库insert、update、delete、select访问次数
			查询结果：
				Com_binlog	0			执行二进制日志相关操作次数
				Com_commit	4082			执行事务提交次数	
				Com_delete	507			执行delete删除操作次数
				Com_import	0			执行导入操作次数
				Com_insert	47222			执行insert插入操作次数
				Com_repair	0			执行修复操作次数
				Com_revoke	0			执行撤销权限次数
				Com_select	15342465		执行select查询操作次数
				Com_signal	0			执行信号操作次数		
				Com_update	2325446			执行update修改操作次数		

			补充：	查看insert、delete、update、select次数占比，对占比较大的语句(主要是select语句)进行SQL优化
				_个数为7

		慢查询日志：
			慢查询日志记录所有执行时间超过指定参数(long_query_time,默认10秒)所有SQL语句日志

			Linux：
				查看慢查询日志是否开启：show variables like 'slow_query_log'
				
				编辑配置文件：vi /etc/my.cnf

				开启慢查询日志，配置：
					slow_query_log = 1				开启MySQL慢查询日志开关
					long_query_time = 2				设置慢查询日志为2秒，SQL语句执行时间超过2秒，视为慢查询，记录慢查询日志

				重启MySQL服务器：sudo systemctl restart mysql

				查询日志文件：sudo cat /var/lib/mysql/localhost-slow.log

				测试慢查询日志：
					执行SQL：select * from tb_sku;						假设tb_sku中有1000w条数据，查询时间为13.25
					查看日志文件：sudo cat /var/lib/mysql/localhost-slow.log			日志文件会将此条SQL记录
		
			Windows：
				查看慢查询日志是否开启：show variables like 'slow_query_log'
				
				编辑配置文件：my.ini
						
				开启慢查询日志，配置：
					slow_query_log = 1				开启MySQL慢查询日志开关
					long_query_time = 2				设置慢查询日志为2秒，SQL语句执行时间超过2秒，视为慢查询，记录慢查询日志
					slow_query_log_file = "慢查询日志文件路径"		设置慢查询日志文件路径

				重启MySQL服务器：
					win + R输入services.msc打开服务列表选择MySQL服务选择重新启动

				查询日志文件：
					my.ini配置文件：slow_query_log_file = "C:/ProgramData/MySQL/MySQL Server X.X/mysql-slow.log"
					查看日志文件：type C:/ProgramData/MySQL/MySQL Server X.X/mysql-slow.log
				
				分析慢查询日志：
					执行SQL：select * from tb_sku;						假设tb_sku中有1000w条数据，查询时间为13.25
					查看日志文件：type C:/ProgramData/MySQL/MySQL Server X.X/mysql-slow.log	日志会将此条SQL记录

		profile操作：			profile操作用于对当前会话执行SQL性能分析			
			select @@have_profiling;			查询当前MySQL服务器是否支持查询性能分析(Profiling)功能
			查询结果：	
				@@have_profiling	NO		profiling性能分析功能默认关闭

			开启profiling性能分析：set profiling = 1；					

			show profiles；					查看在当前会话每一条SQL执行的耗时情况
			show profile for query query_id;		查看指定query_id的SQL语句各阶段耗时情况
			show profile cpu for query query_id;		查看指定query_id的SQL语句CPU使用情况
				
				补充：当前会话执行的每一条SQL <==> 在navicat中新建查询窗口中所有执行的SQL

		explain操作：			explain操作展示SQL查询的执行计划
			explain select 字段列表 from 表名 where 条件；			
			desc select 字段列表 from 表明 where 条件；			注意：直接在select语句之前加关键字explain/desc

			查询结果：
				id			select查询序列号，表示执行select子句或者操作表的顺序(id相同，执行顺序从上到下；id不同，值越大先执行)
				select_type		查询类型
					SIMPLE：简单查询
					PRIMARY：主查询/最外层查询
					SUBQUERY：子查询
					DEPENDENT SUBQUERT：依赖外部查询的子查询
					UNION：联合查询中第二个或后续查询
					DERIVED：派生表(子查询中的临时表)
					MATERILIZED：物化子查询
				table			查询表名
				partitions		分区
				type			连接类型
					NULL：无法执行查询
					system：系统表扫描	
					const：查找一常数
					eq_ref：基于唯一索引查询
					ref：基于非唯一索引查询
					range：基于索引范围查询
					index：索引查询
					all：全表查询
				possible_keys		表中可能使用索引
				key			表中实际使用索引
				key_len			使用索引长度
				ref			索引关联的字段
				rows			查询记录数
				filtered		返回结果行数占需读取行数百分比
				Extra			额外执行信息
				
				补充：type连接类型由好到差进行排序

	索引使用原则：
		组合索引使用原则：
			最左前缀法则(组合索引)：
				组合索引：一个索引包含多个列，一个表可以有多个多列索引
				最左前缀法则：查询从索引最左列开始，并且不跳过索引中的列，若查询跳过索引中某一列，索引将部分失效(后面的字段索引失效)

			范围查询(组合索引)：
				组合索引：一个索引包含多个列，一个表可以有多个多列索引
				范围查询失效：组合索引这种，出现范围查询(>，<)，范围查询右侧列索引失效
				规避方法：使用>= 或 <=进行范围查询，右侧列不失效


		索引失效情况：
			索引列运算：尽量不要在索引列上进行运算，索引失效			注意：索引列失效 = 性能降低，执行时间变长 ≠ 运算不能执行
			
			字符串不加引号：字符串类型不加引号，索引失效				注意：索引失效 = 性能降低，执行时间变长 ≠ 查询结果不正确
			
			模糊查询：头部模糊查询索引失效，尾部模糊查询索引不失效	
			
			or关键字：or关键字前的条件中列有索引，or关键字后的条件中列没有索引，所有索引失效

			数据分布影响：使用索引查询性能分析比全表扫描性能更慢，索引返回大批量数据，全表扫描性能更快，索引失效


		SQL提示：在SQL语句中加入人为提示达到优化操作目的
			use index：		指定索引查询
				explain select * from tb_user use index(idx_user_pro) where profession = '软件工程'；
		
			ignore index：		指定忽略索引查询
				explain select * from tb_user ignore index(idx_user_pro) where profession = '软件工程'；
		
			force index：		强制使用指定索引
				explain select * from tb_user force index(idx_user_pro) where profession = '软件工程'；		


		覆盖索引：查询条件使用索引，查询所需的列在该索引中能全部找到，直接通过索引查找，无需回表查询
			create index idx_name on employees（first_name，last_name）；					
				在表employees中对first_name，last_name创建索引
			
			select first_name,last_name from employees where first_name = 'Jonh' and last_name = 'Doe';
				索引idx_name包含查询需要first_name和last_name,查询通过覆盖索引完成，无需回表查找id和其他列
			
				补充：在实际开发中尽量少使用select *，select *需要回表查询，查询性能较低


		前缀索引：主要用于对字符串进行索引时优化性能。前缀索引不对整个字符串进行索引，只对字符串部分前缀进行索引		
			create index idx_name on table_name(column(n));

				例：create index idx_email_5 on tb_user(email(5));		为tb_user表的email字段建立长度为5的前缀索引

				测试：	select * from tb_user where email = 'dajdajwdaw'；
					explain select * from tb_user where email = 'dajdajwdaw';
							
					查询结果：	key	idx_email_5
				
			前缀长度：
				选择性：不重复的索引值和数据表的记录总数比值
				索引选则性越高查询效率越高，唯一索引选择性是1(最好索引选择性，性能最好)
			
			
		单列/组合索引：
			单列索引：一个索引包含一个列
			组合索引：一个索引包含多个列			在实际业务中，如果存在多个查询条件，针对查询字段建立索引，建议建立联合索引
			
				
*******	SQL优化(主要是索引优化)：		补充：优化包括两方面：SQL优化 + 数据库设计优化，若SQL优化没有可改善的地步，改善数据表设计
		insert优化：
			少量数据插入优化：
				优化方法1：批量插入数据		批量插入数据不超过1000条
				优化方法2：手动控制事务		mysql中事务提交方式默认自动提交，每执行一条insert语句，事务自动提交，若有1000w条事务会频繁事务开启和提交
				优化方法3：主键顺序插入		主键顺序插入性能高于主键乱序插入

			大批量数据插入优化：
				将几百万条数据保存到CSV文件中，通常使用CSV或TSV格式，每行一条记录，数据字段用逗号分隔
					1,John Doe,john@example.com
					2,Jane Smith,jane@example.com
					3,Bob Johnson,bob@example.com
					...
				
				表结构已经建立：
					CREATE TABLE users (
    						id INT PRIMARY KEY,
    						name VARCHAR(255),
    						email VARCHAR(255)
					);
					
				使用load data infile插入数据：
					load data infile 'C:/path/to/your/file.csv'		C:/path/to/your/file.csv：大批量数据csv文件路径	
					into table 'users'					users：表名
					fields terminated by ','				字段分隔符，csv文件一般是','			
					enclosed by '""'					字段用双引号""包裹(可选)
					lines terminated by '\n'				行分隔符，csv文件一般是换行符		
					ignore 1 lines；						文件有表头(字段名注释)，忽略直接跳过

				Windows：
					命令行连接MySQL，启用local：mysql --local-infile -u root -p					

					在my.ini配置文件中，确保local_infile被启用：local_infile = 1
					
					检查local_infile状态：show variables like 'local_infile';

					使用load data infile插入数据

				Linux：
					命令行连接MySQL，启用local：mysql --loacl-infile -u root -p
					
					设置全局参数local_infile，确保local_infile被启用：local_infile = 1
					
					检查local_infile状态：show variables like 'local_infile';
					
					使用load data infile插入数据
		
		主键优化：
			满足业务需求情况下，尽量降低主键长度
			插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键
			尽量不要使用UUID做主键或是其他自然主键
			业务操作时，避免对主键修改
			
		order by优化：
			Using filesort：
				通过表的索引或全表扫描，读取满足条件的数据行，在排序缓冲区sortBuffer中完成排序操作
				filesort算法：无法使用索引直接返回排序结果的排序
				
			Using index(推荐使用)：
				通过有序索引顺序扫描直接返回有序数据，不需要额外排序，性能较高
			
			测试：	explain select id，age，phone from tb_user order by age；
			测试结果：Extra	Using filesort
			测试：	explain select id，age，phonr from tb_user order by age，phone；			
			测试结果：Extra	Using filesort

			创建索引：create index idx_user_age_phone on tb_user(age,phone);				注意：age在前，phone在后

			测试：	explain select id，age，phone from tb_user order by age；
			测试结果：Extra	Using index
			测试：	explain	select id，age，phont from tb_user order by age,phone;			补充：索引全部升序提高性能
			测试结果：Extra 	Using index

			测试：	explain select id，age，phone from tb_user order by age desc，phone desc；	补充：索引全部降序提高性能
			测试结果：Extra	BackWard index scan；Using index						补充：BackWard：反向扫描索引

			测试：	explain	select id，age，phone from tb_user order by phone，age；			注意：phone在前，age在后
			测试结果：Extra	Using index；Using filesort						注意：排序遵循最左前缀法则，从左侧开始，跳过索引失效

			测试：	explain select id，age，phone from tb_user order by age asc;phone desc;		注意：age在前升序，phone在后降序
			测试结果：Extra	Using index；Using filesort						
			
			创建索引：create index idx_user_age_pho_ad on tb_user(age asc, phone desc);
			测试：	explain select id，age，phone from tb_user order by age asc;phone desc;
			测试结果：Extra	Using index
		
			order by优化原则：
				根据排序字段建立合适索引，多字段排序，遵循最左前缀法则
				尽量使用覆盖索引
				多字段排序，一个升序一个降序，注意组合索引在创建时的规则			
			
		group by优化：
			测试：	explain select profession，count(*) from tb_user group by profession;
			测试结果：Extra	Using temporary								注意：temporary临时表，性能较低
			
			创建索引：create index idx_user_pro_age_sta on tb_user(profession,age,status);

			测试：	explain select profession，count(*) from tb_user group by profession;
			测试结果：Extra	Using index

			测试：	explain select age，count(*) from tb_user group by age;				注意：不满足组合索引最左前缀法则，返回Using temporary
			测试结果：Extra	Using index；Using temporary；
			测试：	explain	select profession，age，count(*) from tb_user group by profession,age;	补充：对于分组操作，在联合索引中，也符合最左前缀法则	
			测试结果：Extra	Using index；
			
			group by优化原则：
				分组操作时，可以通过索引提高效率
				分组操作时，索引使用满足最左前缀法则	
			
		limit优化：
			测试：	select * from tb_sku limit 0，10；		耗时：0秒			
			测试：	select * from tb_sku limit 1000000，10；		耗时：1.66秒			返回1000000-1000010记录
			测试：	select * from tb_sku limit 5000000，10；		耗时：16.79秒			返回5000000-5000010记录
				推出：分页起始位置越靠后，分页查询效率越低
			
			优化：	explain select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;	耗时：11.46秒

			limit优化原则：覆盖索引 + 子查询
				
		count优化：
			测试：	explain select count(*) from tb_user;		耗时：11.02秒		第一次执行使用InnoDB引擎累积计数
				explain select count(*) from tb_user;		耗时：0.00秒		第二次执行使用MyISAM引擎读取计数结果
				
				补充：	MyISAM引擎存储表总行数快速返回count(*)结果，性能较高		
					InnoDB引擎需逐行读取数据计算count(*),性能较低
			
			优化：	explain select count(1) from tb_user;					count(1)会稍微提高性能
				explain select count(*) from tb_user where status = 'active';		表中status列有索引，通过索引提高性能
				
			效率：count(字段) < count(主键id) < count(1) ≈ count(*)		
			建议：建议使用count(*)	
			
		update优化：
			测试(字段不加索引):	update course set name = 'javaEE' where id = 1;		注意：不加索引字段更新时将整张表锁住

			测试(字段加索引)：	
				创建索引：create index idx_course_name on course(name);		
				字段更新：update course set name = 'javaEE' where id = 1;			注意：加索引字段更新时将更新行数据锁住

			优化思路：给更新字段添加索引


	锁：
		锁：计算机协调多个进程或线程并发访问某一资源的机制
			
		锁分类：
			全局锁：锁定数据库中所有表
			表级锁：每次操作锁住整张表
			行级锁：每次操作锁住行数据

		全局锁：
			作用：锁定整个数据库系统，对数据库中每张表都加锁，所有表处于只读(只查询)状态
	
			使用场景：数据库数据备份(将数据库中的数据备份成sql文件存储到磁盘)
			
			全局锁数据备份操作：
				加全局锁：flush tables with read lock;
				备份数据库：mysqldump -h主机地址 -u用户名 -p密码 备份数据库名 > 备份文件名
				释放全局锁：unlock tables;		
			
			数据库备份示例：
				flush tables with read loack;
				mysqldump -h127.0.0.1 -uzxhc -pZxhc@1234test! allcore_cp_qh_dev > F:/allcore.sql		
				unlock tables;
				
					注意：mysqldump是MySQL提供的工具非SQL命令，在cmd窗口运行
			
			全局锁问题：
				主库备份，备份期间不能执行更新，业务停滞
				从库备份，备份期间不能执行主库同步的二进制日志，导致主从延迟

				补充：	InnoDB引擎，可以在备份时加参数--single-transaction完成不加锁一致性数据备份
					mysqldump --single-transaction -h127.0.0.1 -uzxhc -pZxhc@1234test! allcore_cp_qh_dev > F:/allcore.sql
									
		表级锁：		表级锁主要由MyISAM存储引擎使用，InnoDB存储引引擎更多使用行级锁，主要介绍InnoDB中表级锁
			表级锁种类：
				共享锁：允许多个事务同时读取数据，不允许修改数据			注意：所有共享锁被释放后，其他事务才能施加排他锁
				排他锁：禁止其他事务对该表进行任何操作，直到锁被释放
							
			InnoDB表级锁分类：	
				表锁：锁住整个表，其他线程或进程无法对该表进行更改(插入、更新、删除)
					分类：
						写锁：事务需要修改数据对表加锁，本事务可以读取数据/修改数据			修改数据加锁，其他事务不能读/写数据
						读锁：事务需要读取数据对表加锁，其他事务可以读取数据但是不能修改数据		读取数据加锁

					操作：
						添加写锁：lock tables 表名 write;
						添加读锁：lock tables 表名 read;
						释放锁：unlock tables;

				元数据锁(DML)：事务对表结构修改过程中，其他事务不能同时修改或读取元数据，维护表元数据一致性			
					对表进行查询时，加MDL共享读锁
					对表进行增删该查时，加MDL共享写锁			
				
					SQL对应锁类型：
					对应SQL						锁类型						说明
					lock tables read/write				SHARED_READ_ONLY/SHARED_NO_READ_WRITE
					select、select...lock in share mode		SHARED_READ(读锁)				与SHARED_READ、SHARED_WRITE兼容，与EXCLUIVE互斥
					insert、update、delete、select...for update	SHARED_WRITE(写锁)				与SHARED_READ、SHARED_WRITE兼容，与EXCLUIVE互斥
					alter table...					EXCLUSIVE(排他锁)				与其他MDL锁都互斥

						注意：	共享读锁(SHARED_READ)与共享写锁(SHARED_WRITE)不互斥，事务未提交不同事务可以操作同一张表
							共享锁(SHARED_READ/WRITE)与排他锁(EXCLUSIVE)互斥，事务未提交前不同事务不可以操作同一张表

					元数据锁操作：
						查询元数据锁：select object_type，object_schema，object_name，lock_type，lock_duration from performance_schema，metadata_locks;

				意向锁：使用意向锁不用检查每行数据是否加锁减少表锁的检查
					作用：多个事务并发访问数据库时，预先在表上设置意图锁，检查表是否可以加上行锁，根据意向锁类型判断是否可以加行锁

					意向共享锁(IS)：事务操作数据时对数据添加行锁之前添加意向共享锁，通知其他事务可以在该表添加共享锁，不能设置排他锁		其他事务可加共享锁
					意向排他锁(IX)：事务操作数据时对数据添加行锁之前添加意向排他锁，通知其他事务不能在该表添加共享锁，不能设置排他锁		其他事务不加排他锁
				
					意向锁兼容性：
								IS		IX		S		X
						IS(意向共享锁)	✔️		✔️		✔️		×
						IX(意向排他锁)	✔️		✔️		×		×
						S(共享锁)	✔️		×		✔️		×
						X(排他锁)	×		×		×		×
						
					查询意向锁及行锁加锁情况：
						select object_schema，object_name，index_name，lock_type，lock_mode，lock_data from performance_schema.data_locks;

		行级锁：		InnoDB存储引擎支持行级锁，MyISAM存储引擎不支持行级锁
			作用：锁定单行行数据，其他事务不能对该行进行修改操作，不同事务能并发操作表中不同数据行

			行级锁分类：
				行锁：锁定单行记录，防止其他事务对此条记录进行修改操作
					类型：
						共享锁：允许多个事务同时读取数据，不允许修改数据，直到加锁事务完成
						排他锁：禁止其他事务对该行数据进行任何操作(读取/修改/删除)
					
					行锁兼容性：		
									请求锁		请求锁
									S(共享锁)	X(排他锁)
						当前锁	S(共享锁)	兼容		冲突
						当前锁	X(排他锁)	冲突		冲突

					执行SQL对应行锁类型：
						SQL				行锁类型			说明
						insert语句			排他锁			自动加锁
						update语句			排他锁			自动加锁
						delete语句			排他锁			自动加锁
						select语句			不加锁
						select语句 + lock in share mode	共享锁			手动在select后加lock in share mode
						select语句 + for update		排他锁			手动在select后加for update

					操作：
						查询意向锁及行锁加锁情况：
							select object_schema，object_name，index_name，lock_type，lock_mode，lock_data from performance_schema.data_locks;
						添加共享锁：select语句 + lock in share mode;
						添加排他锁：select语句 + for update;
					
				间隙锁：锁定两个数据行之间的"间隙"区域，防止其他事务在该"间隙"间隙进行插入操作，产生幻读
					幻读：
						插入幻读：事务读取某个范围的数据时，间隙锁确保其他事务不能在该范围内插入新数据，避免新插入行被当前事务遗漏
						删除幻读：事务读取某个范围的数据时，间隙锁确保其他事务不能在该范围内删除行数据，避免删除行被当前事务忽略

					间隙锁加锁特性：
						1.索引上等值查询(唯一索引)，给不存在记录加锁，优化为间隙锁
						2.索引上等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询条件，next-key锁退化为间隙锁
						3.索引上的范围查询(唯一索引)，访问到不满足条件的第一个值为止

					间隙锁演示：
						1.索引上等值查询(唯一索引)，给不存在记录加锁优化为间隙锁
						第一个事务：	
							begin；
								update stu set age = 10 where id = 5；				注意：第一个事务提交之后，第二个事务才能成功插入数据
							end&&								

						第二个事务：
							begin；
								insert into stu values(7,'Ruby',7)；				补充：第一个事务提交，否则会给表添加间隙锁
							end&&

						2.索引上等值查询(非唯一索引)，向右遍历最后一个值不满足查询条件，next-key锁退化为间隙锁
						第一个事务：
							begin；
								select * from employees where salary = 80000；			注意：对索引id_salary执行索引查找，对80000 <= salary < 90000添加临键锁
							end&&									补充：等事务2执行结束，事务1关闭
							
						第二个事务：
							begin；
								insert into employees (id,name,salary) values(6,'Frank',85000)；	注意：salary = 85000，临键锁退化为间隙锁，并非具体行
							end&&						
						
						3.索引上范围查询(唯一索引)，访问到不满足条件的第一个值为止
						第一个事务：
							begin；
								select * from employees where salary between 5000 and 10000;	注意：第一个事务提交成功之后，第二个事务才能成功插入数据
							end&&
						
						第二个事务：
							begin；
								insert into employees(id,name,salary) values(5,'Eve',60000)	补充：第一个事务提交，否则会给表添加间隙锁
							end&&

				临键锁(next_key锁)：行锁和间隙锁组合，同时锁住数据和"间隙"，避免其他事务在此范围内进行修改操作
					补充：默认情况下，InnoDB在RR(REPEATABLE READ)事务隔离级别下运行，InnoDB使用next-key锁进行搜索和索引扫描


	视图(View)：
		定义：视图是一种虚拟存在的表(一张伪表，sql语句的查询结果)，数据库只存放视图的定义(自定义查询的SQL语句)，不存放视图对应数据。
		     视图包含一系列带有名称的行和列数据，来自自定义SQL查询的表(基表)，在使用视图时动态生成

		视图操作：
			创建视图：create [or replace] view 视图名称[(列名列表)] as select语句 [with cascaded check option];
				例：	create or replace view stu_v1 as select id,name from student where id <= 10;
				结果：	OK
		
			查询视图：
				查看创建视图语句：show create view 视图名称;
					例：show create view stu_v1;
					结果：	View		Create View		character_set_client		collation_connection
						stu_v1		创建View语句		utf8mb4				utf8mb4_0900_ai_ci
				
				查看视图数据：select * from 视图名称;
					例：select * from stu_v1;
					结果：	id列		name列
			
			修改视图：
				方式一：create [or replace] view 视图名称[(列名列表)] as select语句；
					例：create or replace view stu_v1 as select id,name,no,from student where id <= 10;
					结果：OK
					查询视图：seletc * from stu_v1；
					结果:	id列		name列		no列

				方式二：alter view 视图名称[(列名列表)] as select语句；
					例：alter view stu_v1 as select id，name，no from student where id <= 10;
					结果：OK
					查询视图：select * from stu_v1;
					结果：	id列		name列		no列
			
			删除视图：drop view [if exists] 视图名称 [,视图名称...]；
				例:drop view if exists stu_v1;
				结果：OK
		
		检查选项：		
		with cascaded check option：		
			cascaded：当对象属性发生变化时，该变化自动传递到与该对象相关联的其他对象
				创建视图：create or replace view stu_v1 as select id,name from student where id <= 10 with [cascaded] check option；
				插入数据：insert into stu_v1 values(6,'Tom');			结果：插入成功
				插入数据：insert into stu_v1 values(30,'Jack');			结果：插入不成功	报错：check option failed stu_v1

					原因：创建视图View时有检查选项with check option,不满足where id <= 10之后的数据不会被插入

		with local check option：
			local：当对象属性发生变化时，操作仅限于当前视图的本地对象，不影响其他相关对象或数据
				创建视图：create view v1 as select id，name from student where id <= 15;
				插入数据：insert into v1 values(5,'Tom');				结果：插入成功
				插入数据：insert into v1 values(16,'Jack');			结果：插入成功	原因：没有检查选项

				创建视图：create view v2 as select id，name from v1 where id >= 10 with local check option;
				插入数据：insert into v2 values(13,'Mack');			结果：插入成功
				插入数据：insert into v2 values(17,'Hack');			结果：插入成功	原因：v2依赖v1，插入条件满足v2，v1没有检查选项

				创建视图：create view v3 as select id，name from v2 where id < 20;
				插入数据：insert into v2 values(14,'Yua');			结果：插入成功	原因：插入条件满足v3条件，v3依赖v2，满足条件，v1没有检查选项
				
			补充：视图中的行与基础表中的行必须存在1:1关系，否则不可更新


	存储过程(数据库SQL语句的封装与重用)：
		定义：存储过程是一组预定义SQL的集合，可以通过调用存储过程执行SQL，减少数据在数据库和应用服务器之间的传输
		
		存储过程操作：
			指定SQL结束符：delimiter &&						例：	delimiter &&

			创建存储过程：								例：
				create procedure 存储过程名称(参数列表)					create procedure p1()
				begin									begin
					SQL语句 									select count(*) from student;
				end&&									end&&
											
				参数列表：	IN：存储过程输入参数(入参)					delimiter ;		恢复默认SQL结束符;
						OUT：存储过程输出参数(出参)
						INOUT：存储过程输入输出参数(入参 + 出参)

					补充：执行创建存储过程SQL时，关键字delimiter指定SQL语句结束符
					注意：在SQL语句中分号；代表SQL语句结束
			
			调用存储过程：call 名称 [参数];						例：	call p1();

			查看存储过程：
				select * from information_schema.routings where routing_schema = '存储过程所在数据库'；		查询指定数据库存储过程及状态信息
			(常用)	show create procedure 存储过程名称								查询某存储过程定义

			删除存储过程：drop procedure [if exists] 存储过程名称;			例：	drop procedure if exists p1;

		存储过程参数/变量/控制语句/条件处理程序/数据类型/存储函数：
			参数：
				IN:存储过程输入参数
				OUT：存储过程输出参数
				INOUT：存储过程输入输出参数(入参/出参)

				语法：
					create procedure 存储过程名称([IN/OUT/INOUT 参数名 参数类型])
					begin		
						--SQL语句
					end;

				创建存储过程：
					delimiter &&

					create procedure p4(in score int,out result varchar(10))			create procedure p5(inout score double)
					begin										begin
						if score >= 85	then								set score := score * 0.5;
							set result := '优秀';						end;

						elseif 60 <= score < 85 then						set @score = 78;
							set result := '及格';						call p5(@score);		补充：@score是输出参数
															select @score;
						else 								
							set result := '不及格';

						end if;
						select @result;
					end&&
					
					delimiter ;

				调用存储过程：call p4(68,@result);			补充：@result是输出参数
					
			
			变量：
				系统变量：由MySQL服务器提供，非用户定义，属于服务器层面
					分类：
						全局变量：对所有会话(navicat新建连接窗口)有效
						会话变量：仅在当前会话(navicat新建连接窗口)有效
						
					查看系统变量：
						show [session|global] variables;			查看所有系统变量
						show [session|global] variables like '...';		模糊匹配查找系统变量
						select @@[session|global]系统变量名；			查找指定值的系统变量			

					设置系统变量：
						set [session|global] 系统变量名 = 值;			例：set session autocommit = 0;		
						set @@[session|global].系统变量名 = 值;			例：set @@session.autocommit = 0;

				局部变量：根据业务需求定义在局部(存储过程定义begin...end内)生效的变量
					查看局部变量：
						select 变量名;						例：select stu_count;
					
					声明局部变量：	
						declare 变量名 变量类型 [default ...];			例：declare stu_count int [default 0];
							变量类型：int、bigint、char、varchar、date、time等
							default：变量默认值		
	
					设置局部变量：
						set 变量名 = 值;						例：set stu_count = 100;
						set 变量名 := 值;
						select 字段名 into 变量名 from 表名：			例：select count(*) into stu_count from student;

					示例：
						创建存储过程：
							delimiter &&					

							create procedure p2()
							begin
								declare stu_count int default 0;
								set count(*) into stu_count from student;
								select stu_count;							

							end&&

							delimiter ;

						调用存储过程：call p2();
				
				用户自定义变量：用户根据业务需求自己定义的变量，无需提前声明。			作用域：当前会话
					查看用户自定义变量：
						select @变量名;						例：select @myName;
						
						注意：select @abc;	查询数据库中没有的变量查询的结果为null			

					设置用户自定义变量：
						set @变量名 = 变量值;					例：set @myName = 'itcast';
						set @变量名 := 变量值;					例：set @myName := 'itcast';
						select @变量名 := 变量值;					例：set @myGender := '男';
						select 字段名 into @变量名 from 表名;			例：select count(*) into @mycount from tb_user; 	
					
						注意：在设置自定义变量时，推荐使用:=
					
			控制语句：
				默认：delimiter &&

				if语法：									
					if	条件	then
					elseif	条件	then
					else	...
					end if;
				
					存储过程(if语法运用)：
						create procedure p1()
						begin
							declare score int default 58;			声明变量
							declare result varchar(10);			声明变量

							if score >= 85	then
								set result := '优秀';

							elseif 60 <= score < 85 then
								set result := '及格';

							else
								set result := '不及格';

							end if;
							select result;
						end&&

				case语法：
					case 值：					case：
						when 值1	 then SQL语句;				when 条件1  then SQL语句;
						when 值2	 then SQL语句;				when 条件2  then SQL语句;
						else SQL语句					else SQL语句
					end case;					end case;

					存储过程(case语法运用):
						create procedure p6(in month int)
						begin
							declare result varchar(10);
						
							case
								when month >= 1 and month <= 3 then
									set result := '第一季度'；
											
								when month >= 4 and month <= 6 then
									set result := '第二季度'；

								when month >= 7 and month <= 9 then
									set result := '第三季度'；

								when month >= 10 and month <= 12 then
									set result := '第四季度'；

								else 
									set reault := '非法参数'；
						end&&

				while语法：
					while 条件 do
						SQL语句...
					end while;

					存储过程(while语法运用)：
						create procedure p7(in n int)
						begin
							declare total int default 0;			声明变量
							while n > 0 do
								set total := total + n;
								set n = n - 1;
							end while;
							select total;			
						end;

				repeat语法：有条件的循环控制语句，满足条件退出循环
					repeat
						SQL语句
						until 条件
					end repeat;

					存储过程(repeat语法运用)：
						create procedure p8(in n int)
						begin
							declare total int default 0;			声明变量
										
							repeat
								set total := total + n;
								set n := n - 1; 
							until n <= 0
							end repeat;

							select total;
						end&&	

				loop语法：实现简单循环，不在SQL逻辑中增加退出循环条件，实现简单死循环
					leave label：退出指定标记循环体
					iterate label：直接进入下一次循环

					[label] loop				label：循环或控制语句的标记
						SQL逻辑	
					end loop;

					存储过程(loop语法运用)：
						create procedure p9(in n int)
						begin
							declare total int default 0;			声明变量

							sum loop
								if n <= 0 then 	
									leave sum;						

								set total := total + n;
								set n := n - 1;
							end loop sum;
							select total;
						end&&

			条件处理程序：定义在流程控制结果执行过程中遇到问题相应的处理步骤
				语法：declare handler_action handler for condition_value [,condition_value]...statement;
				
					handler_action：
						continue：继续执行当前程序
						exit：终止执行当前程序
							
					condition_value：
						SQLSTATE sqlstate_value		状态码
						SQLWARNING			所有以01开头的sqlstate代码简写
						NOT FOUND			所有以02开头的sqlstate代码简写
						SQLEXCEPTION			所有没有被sqlwarning 或 not found捕获的sqlstate代码简写
				
				示例：	declare exit handler for SQLSTATE '02000' close u_cursor;
					declare exit handler for NOT FOUND close u_cursor;
						
			数据类型(游标)：
				游标：存储查询结果集的数据类型，在存储过程和函数中使用游标对结果集进行循环处理
				
				游标操作：
					声明游标：declare 游标名 cursor for 查询语句;
					打开游标：open 游标名;
					获取游标：fetch 游标名 into 变量[,变量];
					关闭游标：close 游标名;
				
				游标示例：
					要求：根据参数uage查询用户表tb_user所有用户年龄小于等于uage的用户姓名(name)和专业(profession)，将用户的姓名和专业插入到新建的一张表中
					
					delimiter &&

					create procedure p11(in uage int)
					begin					
						declare uname varchar(100);								注意：变量的声明要在游标之前			
						ceclare uprofession varchar(100);
						declare u_cursor cursor for select name,profession from tb_user where age <= uage;	声明游标
						declare exit handler for SQLSTATE '02000' close u_cursor;				声明条件处理器(二者选一)
						declare exit handler for NOT FOUND close u_cursor;					声明条件处理器(二者选一)							
						
						create table tb_user_profession(							创建新表
							id int primary key auto_increment,
							name varchar(100),
							profession varchar(100)
						);

						opne u_cursor;										打开游标
						while true do
							fetch u_cursor into uname,uprofession;						赋值
							insert into u_cursor values(null,uname,uprofession);				插入数据	
						end while;		
						close u_cursor;										关闭游标
						
					end&&
						
					delimiter ;

						执行报错：[02000][1329]No data-zero rows fetched,selected or processed
						原因：while true死循环获取不到数据
						解决方法：声明条件处理器(Handler)

	存储函数：
		定义：有返回值的存储过程，存储函数返回值为IN类型
				
		语法：	create function 存储函数名([参数列表])
			returns type [characteristic]
			begin
				SQL语句
				return ...;
			end;

			characteristic补充：
				determinstic：传入参数与返回值一样
				no sql：不包含SQL语句
				reads sql data：只包含查询SQL,不包含插入SQL
			
		示例：
			要求：计算从1累加到n的值，n为传入的参数
			实现：
				创建存储函数：
					create function fun1(n int)
					returns int determinstic
					begin
						declare total int default 0;
					
						while n > 0 do
							set total := total + n;
							set n := n - 1;
						end while;
					
						return total;					
					end;
				
				调用存储函数：select fun1(100);
		
	触发器(trigger)：在insert/update/delete之前/后，触发执行触发器中定义的SQL语句集合
			
		触发器类型：
			insert型触发器		new 表示将要或已经新增的数据
			update型触发器		old 表示修改之前的数据，new 表示将要或已经修改后的数据
			delete型触发器		old 表示将要或已经删除的数据
		
			补充：触发器只支持行级触发器，不支持语句级触发器
			
		触发器语法：
			创建触发器：
				create trigger 触发器名
				before/after insert/update/delete
				on 表名 for each row							for each row：行级触发器
				begin
					触发器执行的SQL语句
				end;
				
			查看触发器：show triggers;
			删除触发器：drop trigger [数据库名] 触发器名;

		触发器示例：
			delimiter &&
			insert类型：
				创建触发器：
					create trigger before_insert_employees 				作用：在employees插入新数据之前，将create_time字段设置为当前时间
					before insert				
					on employees for each row
					begin
						set new.create_time = now();				new：访问即将插入的行数据
					end&&	

				查看触发器：show triggers
				
				删除触发器：drop trigger before_insert_employees

			update类型：
				创建触发器：
					create trigger after_update_employees				作用：更新前salary != 更新后salary，将在employees_log中插入一条记录
					after update
					on employees for each row
					begin
						if old.salary != new.salary then
							insert into employees_log(employee_id,operation,old_salary,new_salary,change_time)
							values(new.id,'update',old,salary,new salary,now());
					end&&

				更新数据：update employee set salary = '18000' where id = 3463; 	
					
				查看触发器：show triggers;
				
				删除触发器：drop trigger after_update_employees;

			delete类型：
				创建触发器：
					create trigger before_delete_empoyees				作用：
					before delete				
					on employees for each row
					begin
						insert into employees_log(employee_id,operation,name,delete_time)
						values(new.id,'delete',old.name,now());
					end&&

				删除数据：delete from employees where id = 4343;
				
				查看触发器：show triggers
				
				删除触发器：drop trigger before_delete_employees；

			补充：
				old：访问操作之前的数据，常用于update和delete触发器
				new：访问操作之后的数据，常用于insert和update触发器

	临时表：
		作用：保存临时数据，只在当前连接可见，关闭连接时，数据库自动删除表并释放所有空间
		创建临时表：
			CREATE TEMPORARY TABLE temp_table_name AS
			SELECT column1, column2, ...
			FROM source_table
			WHERE condition;

		插入数据：
			INSERT INTO temp_table_name (column1, column2, ...)
			VALUES (value1, value2, ...);	

		查询临时表：
			SELECT * FROM temp_table_name;	

		修改临时表：
			ALTER TABLE temp_table_name
			ADD COLUMN new_column datatype;

		删除临时表：
			DROP TEMPORARY TABLE IF EXISTS temp_orders;

	元数据(表结构):
		定义：元数据是关于数据库和其对象(如：表、列、索引等)的信息
		存储位置：元数据存储在系统表中，位于MySQL数据库的information_schema数据库中

		常用元数据查询：
			show databases；				查看所有数据库
			use database_name;			选择数据库
			show tables;				查看数据库中所有表
			desc table_name;				查看表结构	
			show index from table_name;		查看表索引
			show create table table_name;		查看表的创建语句
			select count(*) from table_name;		查看表的行数

	MySQL正则表达式(使用巨少)：			本质上是对查询结果的筛选
		关键字：REGEXP/RLIKE
		基本语法：
			select column1,column2,...
			from table_name
			where 字段名  REGEXP  '正则表达式';
		
		匹配方式/正则模式：			
			.		匹配任意单个字符			WHERE name REGEXP 'a.b';	查找字段中有'a','b',且两个字母之间只有一个字母的记录
			^		匹配字符串的开始			WHERE name REGEXP '^st';	查找字段中st开头的数据
			$		匹配字符串的结束			WHERE name REGEXP 'ok$';	查找字段中ok结尾的数据
			*		匹配0次或多次前面的元素		WHERE name REGEXP 'f*zh';	查找包含没有f或多个f和zh的数据
			+		匹配1次或多次前面的元素		WHERE name REGEXP 'fa+';	查找name中以f开头，含有一个或多个a的数据，例：fac，faak，faaad
			？		匹配0次或1次前面的元素		WHERE name REGEXP 'fa？';	查找name中以f开头，含有0个或1个a的数据，例：ffhefkj，fakoc
			[abc]		匹配字符集中的任意一个字符		WHERE name REGEXP '[abc]'	查找包含abc中任意一个字符的数据
			[^abc]		匹配除字符集中任意一个字符以外的字符	WHERE name REGEXP '[^abc]'	查找不包含abc任意一个字符的数据
			[a-z]		匹配范围内的任意一个小写字母		WHERE name REGEXP '[0-9]'	查找0-9范围内的任意一个数字
			字符串		匹配包含指定字符的文本，|隔开	WHERE name REGEXP 'ok | en';	查找字段中包含ok或en的数据	
			字符串{n,}	匹配字符串至少n次			WHERE e REGEXP '{2}';		查找2个e以上,不包含其它字符的数据，例：ee，eee，eeee...
			字符串{n,m}	匹配字符串字少n次，至多m次		WHERE e REGEXP '{2,3}';		查找至少2个e，至多3个e的数据
			\d		匹配一个数字字符
			\w		匹配一个字母数字字符(包括下划线)
			\s		匹配一个空白字符
			
	SQL注入：	常见的数据库攻击手段，SQL注入是恶意用户在表单中填写包含SQL关键字的数据来使数据库执行非常规代码的过程

		补充：SQL数据库的操作是通过SQL语句来执行的，而无论是执行代码还是数据项都必须写在SQL语句之中，
		     这就导致如果我们在数据项中加入了某些SQL语句关键字（比如说SELECT、DROP等等），这些关键字就很可能在数据库写入或读取数据时得到执行。

		SQL注入产生条件：
			1.前端传给后端的参数用户可控
			2.传入参数拼接到SQL语句中，并且带入数据库中查询
		
		防止SQL注入：
			使用参数化查询或预编译SQL，在执行查询时将输入数据与查询语句分离
			禁用错误消息提示，防止攻击者获取数据库结构的敏感信息
			最小权限原则，给予数据库用户最小的权限，确保用户只能执行必要的操作
			使用ORM框架：使用对象关系映射(ORM)框架可以帮助抽象SQL查询，降低SQL注入风险
			输入验证和转义:对用户输入进行适当的验证，使用合适的转义函数处理输入，防止恶意输入
			
		