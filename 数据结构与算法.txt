数据结构与算法：	程序 = 数据结构 + 算法
	数据结构的基本概念
	基本数据结构
		线性结构	
			线性表					注意：线性表就是集合
			栈和队列(特殊线性表)
			串
			数组和广义表
		非线性结构
			树
			图
	基本数据处理技术
		查找技术
		排序技术
											学生表：学号	姓名	性别	出生日期	政治面貌
数据结构的基本概念：										010	周舟	男	2001/05/30	团员
	数据：能输入到计算机中并能被计算机程序识别和处理的符号集合				例：学生表	数据 > 数据元素 > 数据项
		数值型的数据：整数，实数等
		非数值型数据：文字，图像，图形，声音等
	数据元素(元素/记录/结点)：数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理	例：周舟		
	数据项：构成数据元素的不可分割的最小单位							例：学号/性别		
	数据对象：性质相同的数据元素的集合							例：学籍表 = {周舟}

	关系：数据   --	数据对象		集合的子集
	     数据   --	数据元素		集合的个体元素

	结构：数据元素不是孤立存在的，数据元素相互之间的关系	1:1(一对一) 1:n(一对多) n:n(多对多)
	数据结构：是相互之间存在一种或多种特定关系的数据元素的集合
		数据结构 = 逻辑结构 + 物理结构

		逻辑结构：数据对象中数据元素之间的逻辑关系
		逻辑结构种类：
			划分方式一：
				线性结构：有且仅有一个开始和终端结点，所有结点最多只有一个直接前趋和一个直接后继
					线性表，栈，队列，串

				非线性结构：一个结点可能有多个直接前趋和直接后继
					树，图

			划分方式二：四类基本逻辑结构
				集合：集合结构中的数据元素除同属于一个集合，无其他关系
				线性结构：数据元素之间存在着一对一的线性关系
				树形结构：数据元素之间存在着一对多的层次关系
				图状结构/网状结构：数据元素之间存在着多对多的任意关系
				
		物理结构(存储结构)：数据的逻辑结构在计算机中的存储形式
		物理结构种类：
			顺序存储结构：用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系(1:1/1:n/n:n)由元素存储位置来表示		补充：C/Java中使用数组实现顺序存储结构
			链式存储结构：用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针表示					补充：C中用指针实现链式存储，Java当中使用链表实现链式存储
	
		关系：逻辑结构是数据结构的抽象，存储结构是数据结构的实现
		     

	数据类型：一组性质相同的值的集合以及定义在这个值集合上的一组操作	->	数据类型 = 值的集合 + 值集合上的一组操作
	抽象数据类型(ADT)：一个数据结构以及定义在此数据结构上的一组操作
	抽象数据类型形式定义：抽象数据类型可用(D,S,P)三元组表示
		ADT = (D,S,P)
		D	数据对象
		S	S是D上的关系集
		P	P是对D的基本操作集
		
		抽象数据类型定义格式：					定义抽象数据类型"Circle"
		ADT 抽象数据类型名{						ADT Circle{
			数据对象:<数据对象的定义>					数据对象:D = {r,x,y| r,x,y均为实数}
			数据关系:<数据关系的定义>					数据关系:R = {<r,x,y>| r是半径,<x,y>是圆心坐标}
			基本操作:							基本操作:
				基本操作名(参数表)						Circle(&C,r,x,y)		
					初始条件:<初始条件描述>					操作结果：构造一个圆
					操作结果:<操作结果描述>				double Area(C)
		}ADT 抽象数据类型名								初始条件：圆已存在
	 											操作结果：计算面积
											double Circumference(C)	
	算法：对特定问题求解方法和步骤的一种描述，指令的一种有限序列					初始条件：圆已存在
	指令：一个或多个操作									操作结果：计算周长
	算法的描述：							}ADT Circle			
		自然语言：英语，中文						注意：引用参数，返回操作结果，适用&打头						
		流程图：传统流程图，NS流程图					
		程序代码：C语言程序，Java语言程序				C语言实现抽象数据类型"复数"：
										typedef stryct{	
	程序 = 数据结构 + 算法								float realpart;	
		数据结构通过算法实现操作，算法根据数据结构设计程序				float imagpart;
										}	
	算法特性：									
		有穷性：算法执行步骤有穷，算法执行时间有穷			定义函数：void add(Complex *A，float real，float imag)；
		确定性：对于相同的输入只能得到相同的输出							
		可行性：算法描述的操作可以通过已经实现的基本运算来实现
		有输入：一个算法有零个或多个输入
		有输出：一个算法有零个或多个输出

	算法设计的要求：
		正确性：算法的执行结果能够满足预定的功能和性能要求
		可读性：算法应当是可读的，便于开发者能够轻松理解算法的逻辑
		健壮性：算法应该具有容错性或例外处理能力，对不合理数据进行检查
		效率(时间复杂度)：程序运行从开始到结束所需要的时间，算法中每条语句的频度之和
		存储需求(空间复杂度)：算法执行过程中所需要的最大存储空间

	算法分析：评价算法的优劣程度
		算法分析方法：
			事后统计：将算法实现，测算算法的时间和空间开销		
			事前分析：估算算法所消耗资源			
				
		频度：一条语句重复执行的次数	
		假设：执行一条语句所需的时间均为单位时间
			时间复杂度(T(n)) = Σ频度		补充：时间复杂度取决于最高阶的项
		
		
		时间复杂度定义：
			若有某个辅助函数f(n),当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数(解释：随着n的增大，算法执行时间增长率和f(n)增长率相同)，
			f(n)是T(n)的同数量级函数,T(n) = O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度
	
			最好时间复杂度：在最好情况下，算法的时间复杂度
			最坏时间复杂度：在最坏情况下，算法的时间复杂度
			平均时间复杂度：所有情况的时间复杂度/所有情况出现的次数
			
			求时间复杂度思路：	将消耗时间最多的语句找出来求时间复杂度即可		
					消耗时间最多 <==> 重复执行次数和算法执行时间成正比 <==> 频度最大的基本操作语句执行次数

			n在线性结构和非线性结构中的含义：	n为问题的规模
				集合：n 元素个数
				排序：n 记录数
				矩阵：n 矩阵阶数
				多项式：n 多项式最高次项指数		T(n) = O(n^最高次项指数)
				树：n 树结点个数
				图：n 图顶点数/边数 
			
			算法中基本操作重复执行次数随输入数据集不同而不同：
				for(i = 0;i < n,i++)
					if(a[i] == e) return i+1;		时间复杂度：最好情况：1	最坏情况：n	平均时间复杂度：O(n)
				return 0;
				
			常见时间复杂度排序：O(1) < O(log_2 n) < O(n) < O(nlog_2 n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)	

		空间复杂度定义：程序运行从开始到结束时所需的存储空间的度量，记作：S(n) = O(f(n))，n为问题规模
			算法要占据的空间：
				固定部分：算法执行所需的常量空间，如：存储变量，常量，固定大小的数组等
				可变部分：算法使用的辅助空间，与处理的数据大小和规模有关




基本数据结构：
线性结构：有且仅有一个开始和终端结点，所有结点最多只有一个直接前趋和一个直接后继
	线性表：
		基本概念：由n(n >= 0)个数据元素(结点)a1，a2，...，an组成的有限序列
			L = (a1,a2,...,ai-1,ai,ai+1,...,an-1,an)
				
			a1：起始结点		ai-1：直接前趋			
			an：终端结点		ai+1：直接后继
			下标(1，2，3...，n)：元素的序号，元素在线性表中的位置
			n：元素总个数，表长		
				
			注意:	n = 0时线性表是空表
				an是抽象的符号，具体含义在不同情况下各不相同		
			
		同一线性表中的元素必定具有相同特性，数据元素之间的关系是线性关系
		线性：有且仅有一个开始和终端结点，所有结点最多只有一个直接前趋和一个直接后继
			
		线性表基本操作：
			InitList(&L)			构造空的线性表
			DestoryList(&L)			销毁线性表L，释放L占用的存储空间
			ClearList(&L)			降线性表重置为空表
			ListEmpty(&L)			若L为空表，返回true；否则返回false
			ListLength(&L)			返回L中数据元素的个数
			GetElem(L,i,&e)			用e返回L中第i个元素的值
			LocateElem(L,e,compare())	返回L中第1个与e满足关系compare()数据元素的位序
			PriorElem(L,cur_e,&pre_e)	cur_e是L中的元素数据，且有前驱，用pre_e返回前驱，没有前驱，操作失败
			NextElem(L,cur_e,&next_e)	cur_e是L中的元素数据，且有后继，用next_e返回后继，没有后继，操作失败
			ListInsert(&L,i,e)		在L的第i个位置插入新的数据元素e，L的长度+1
			ListDelete(&L,i,e)		删除L的第i个数据元素，并用e返回其值，L的长度-1
			ListTraverse(L,visit())		遍历L中的元素

		线性表两种基本存储结构：
			顺序存储结构(顺序表)：	逻辑上相邻的数据元素存储在物理上相邻的存储单元中(逻辑位序和物理位序相差1)
						顺序表可以通过下标索引在O(1)时间内找到任一指定的元素(随机存取)	
						
				起始位置/基地址：线性表第1个数据元素a1的存储位置

				顺序表：1 2 3 4 5 6 7 8 9 10		依次存储，地址连续，中间没有空出的存储单元，占用一片连续的存储空间
	
				已知每个元素占用n个存储单元,第一个数据元素的存储位置LOC(a1)
					第(i + 1)个数据元素与第i个数据元素存储位置关系：LOC(a i+1) = LOC(ai) + n
					第i个数据元素的存储位置：LOC(ai) = LOC(a1) + (i-1)n

				C实现顺序表基本操作：	
					静态分配：ElemType data[MaxSize]			静态的"数组"存放数据元素
					动态分配：int *data				动态分配内存，将数组首地址分配给指针data

					#include<stdio.h>
					#define MaxSize 10
					typedef struct{	
						int data[MaxSize];				存储顺序表的数组
						int length；					当前线性表元素个数
					} SeqList；
							
					初始化顺序表：
						Status InitList(SeqList &L){
							L.elem = new ElemType[MAXSIZE];     	为顺序表分配一数组空间，L.elem是基地址，C++语句
        						if (!L.elem) exit(OVERFLOW);        	存储分配失败退出
        						L.length = O;                       	空表长度为0
        						return OK;
						}
						
					销毁线性表：
						void Destorylist(SeqList &L){
							if(L.elem) delete L.elem;		释放存储空间
						}
						
					清空线性表元素(内存仍然在)：
						void ClearList(SeqList &L){
							L.length = 0;				将线性表的长度设置为0			
						}
						
					求线性表长度：
						int GetLength(SeqList L){
							return(L.length);
						}
						
					判断线性表是否为空：
						int IsEmpty(SeqList L){
							if(L.length == 0) return 1;
							else return 0;
						}

					获取顺序表位置i上对应数据元素的值：
						int GetValue(SeqList L,ElemType &e){
							if(i < 1 || i > length) return ERROR;
							e = L.elem[i-1];			逻辑位序和物理位序相差1
							return OK;				
						}

						注意：	&L	引用SeqList结构，使用值和内存地址
							L	只需要读取SeqList值，不需要修改它
						
					插入数据元素：
						插入元素数据：在表的第i(1 <= i <= n+1)个位置上，插入一个新结点e，使长度为n的线性表(a1,...,ai-1,ai,...,an)变成长度为n + 1的线性表(a1,...,ai-1,e,ai,...,an)
							
						思想：
							1.判断插入位置是否合法
							2.判断顺序表存储空间是否已满，若已满返回error
							3.将第n至第i位的元素依次向后移动一个位置，空出第i个位置
							4.将插入新元素e放入第i个位置
							5.表长加1，插入成功返回OK	

						Status insertList(SeqList &L,int i,ElemType e){
							if(i < 1 || i > L.length + 1){return ERROR};			i值不合法
							if(L.length == MaxSize){return ERROR};				当前存储空间已满
							for(j = L.length - 1;j >= i-1.j--){
								L.elem[j + l] = L.elem[j];				将前面的元素赋值给后面的元素
							}
							L.elem[i - l] = e;						将元素e放入第i个位置
							++L.length;							表长加1
							return OK;					
						}

						在各种位置插入的概率是1/(n + 1)						平均时间复杂度:1/(n + 1) * [n(n + 1)/2] = n/2	同阶O(n)
						所有位置被移动次数和：0 + 1 + 2 + 3 + ...... + n / [n(n + 1)/2]

					删除数据元素：
						删除数据元素：顺序表中第i个位置的数据元素删除，使长度为n的线性表(a1,...,ai-1,ai,ai+1,...,an)变成长度为n-1的线性表(a1,...,ai-1,ai+1,...,an)
								
						思想：
							1.判断删除位置i是否合法
							2.将想要删除的元素保留在e中(需要使用保留，不使用删除该步骤)
							3.将第i+1至第n位的元素依次向前移动一个位置
							4.表长减1，删除成功返回OK

						Status deleteList(&L,int i){
							if((i < 1) || (i > L.Length)) return ERROR;			i值不合法
							for(j = i;j <=L.length - 1;j++){
								L.elem[j - 1] = L.elem[j];				将后面的元素赋值给前面的元素
								L.length--;						表长减1
							}	
							return OK;
						}	
					
						在各种位置删除的概率是1/n							平均时间复杂度：(1/n) * [n(n - 1)/2] = (n-1)/2	同阶O(n)
						所有位置被移动次数和：0 + 1 + 2 + 3 + ...... + (n-1) / [n(n - 1)/2]		
							
				
					顺序查找(将记录的关键字和给定值进行比较)：
						int LocateElem(SeqList L,ElemType e){
							for(i = 0；i < L.length;i++){	
								if(L.elem[i] == e){		时间复杂度(最好时间复杂度/最坏时间复杂度)			
									return i + 1;		查找成功，返回i+1；		
								}
							}
							return 0;				查找失败，返回0；
						}
							
						平均查找长度ASL(顺序查找执行次数)：记录的关键字个数与给定值进行比较次数的期望值(期望值：随机变量可能取值的加权平均值)
						每个记录的查找概率：p = 1/n						顺序查找平均查找长度：(1/n) * [n(n + 1)/2]
						所有记录被查找的次数和：1 + 2 + 3 + ...... + n / [n(n + 1)/2]
								
			链式存储结构(链式映像)：	用一组任意地址的存储单元来依次存放线性表的数据元素，存储单元可以是连续的，也可以是不连续的
				链式存储结构结点 = 数据域 + 指针域
					数据域(data)：存储数据元素自身信息的部分
					指针域(next)：存储与前驱或后继结点的逻辑关系 		前驱/后继结点的地址 -> 指针/链	

				链表(非随机存取)：n个结点由指针链组成	
				
				空表：没有数据元素的表，无头结点，头指针为空	head(^)

				单链表：链式存储结构中，结点只包含一个指针域
					单链表存储结构：数据域|指针域	data|next						

					单链表结构示意图：	
						带头结点：	head(next1) -> info|head -> data1|next1 -> data2|next2 -> ... -> data|^
						不带头结点：	(next1) -> data1|next1 -> data2|next2 -> ... -> datan|^

					基本概念：
						头指针(head)：指向第一个元素的地址			next1		补充：头指针命名单链表	
						^:最后一个结点没有后继，结点的指针域设置为空Null			补充：^ = Null = 0
						首元结点：链表中存储第一个数据元素的结点		data1|next1
						头结点：链表首元结点之前附设的一个结点			info|head	补充：头结点可以为空，不能记录链表长度值

						空表：	无头结点，头指针为空			head(^)
							有头结点，头结点的指针域为空			info|^

				C实现单链表基本操作：
					定义单链表：
						typedef Struct{
							char num[8];					定义数据
							char name[8];
							int score
						}ElemType;				

						typedef struct Lnode{					声明结点类型和指向结点的指针类型
							ElemType data；					结点的数据域
							struct Lnode *next；				指向下一个结点的指针
						}Lnode，*LinkList					Lnode(链表结点)：结构体名称		
													*LinkList：指向Lnode结点的指针
						定义头指针：LinkList L					LinkList：用作链表的头指针，表示链表的开始
						定义结点指针：LNode *p； <==>  LinkList p；
											
						L -> 结点1 -> 结点2 -> 结点3 -> ... -> 结点n

					 单链表基本操作：	
						单链表初始化：
							思想：	1.生成新节点作为头结点，用头指针L指向头结点		L -> 头结点(数据域|Null)
								2.将头结点的指针域置空
						
							Status InitList L(LinkList &L){
								L = new LNode;					创建新的结点赋值给头指针L
								L -> next = Null;				L结点的指针域置Null
								return OK;
							}

						判断链表是否为空：
							思想：判断头结点指针域是否为空

							int linkListIsEmpty(LinkList L){
								if(L -> next){
									return 0;
								}else{
									return 1;
								}
							}

						销毁单链表：
							思想：从头结点开始，依次释放所有结点
							
							Status DestoryList(LinkList &L){			L：链表头结点
								Lnode *p;
								while(L){
									p = L;					
									L = L -> next;				
									delete p;
									return OK;
								}
							}
				
								

						清空单链表(链表仍存在，链表中没有元素，成为空链表)
							思想：依次释放所有结点，并将头结点指针域设置为空
							
							Status ClearList(LinkList &L){
								Lnode *p,*q;					*p指向当前删除的结点，*q指向下一个删除的结点
								p = L -> next；	
								while(p){					p的下一个地址一直存在
									q = p -> next;
									delete p;					
									p = q；
								}
								L -> next = null;				将头结点指针设置为空
								return OK;
							}
									
							补充:	p = L			从头指针开始
								p = L -> next		从首元结点开始

						求链表表长：
							思想：从首元结点开始，每存在一个结点即加一							
				
							int getLength(LinkList L){
								LNode *p;					LNode *p指向一个结点
								p = L -> next;					p：第一个结点
								i = 0；
								while(p){
									i++;
									p = p -> next;				循环获取下一结点的地址
								}		
							}

							补充：	p = p -> next;		指向下一结点

						取单链表中第i个元素的内容：
							思想：	1.从第1个结点(L -> next)顺链扫描，p指针指向当前扫描到的结点
								2.j做计数器，j初值为1
								3.当p指向扫描到的下一个结点时，计数器j加1
								4.当j == 1时，p所指的结点即第i个结点

							Status getElem(LinkList L,int i,ElemType &e){
								p = L -> next;
								j = 1;						设置计数器
								while(p && j < 1){			
									p = p -> next;
									++j;
								}
								if(!p || j > 1){
									return ERROR；
								}
								e = p -> data;
								return Ok;
							}

						按值查找:			查找时要从头指针找起，查找时间复杂度O(n)
							根据指定数据获取该数据所在位置(地址)

							Lnode* LocateElem(LinkList L,Elemtype e){
								p = L -> next;
								while(p && p -> data != e){
									p = p -> next;
								}
								return p;
							}
								
							根据指定数据获取该数据所在的位置序号(第几个数据元素)

							int LocateElem(LinkList L,Elemtype e){
								p = L -> next;
								j  = 1;						设置计数器
								while(p && p -> data != e){
									p = p -> next;
									j++;					循环计数加一
								}		
								if(p){
									return j；
								}else{
									return 0;
								}
							}
				
						在第i个结点前插入值为e新结点：		不需要移动元素，只修改指针，时间复杂度为O(1)
							思想：	首先找到a(i-1)的存储位置p
								生成数据域为e的结点s			
								插入新结点：结点a(i-1)的指针域指向新结点，新结点的指针域指向结点ai

							Status insertElem(LinkList &L,int i,ElemType e){
								p = L;J = 0;
								while(p && j < i-1){
									p = p -> next;				找到第i-1个结点
									++j;
								}
								if(!p || j > i-1){				位置非法
									return ERROR；
								}
								s  = new LNode；					创建新结点
								s -> data = e;
								s -> next = p -> next;				将结点s插入到L中
								p -> next = s;
								return OK;
							}	
				
						删除第i个结点：				不需要移动元素，只修改指针，时间复杂度为O(1)
							思想：	找到a(i-1)的存储位置p，保存要删除的ai的值
								a(i-1)的地址指向a(i+1)
								释放结点ai的空间

							Status deleteElem(LinkList &L,int i,ElemType e){
								p = L；
								j = 0;
								while(p -> next && j < i - 1){			找到i-1个结点
									p = p -> next; 
									++j;
								}
								if(!(p -> next) || j > i - 1){
									return ERROR;
								}
								p -> next = p -> next -> next;			a(i-1)的地址指向a(i+1)
								e = p -> next -> data;				保存删除结点的数据域
								delete p -> next;
								return OK;
							}

						单链表的建立：	
							头插法：从最后一个结点开始，倒叙依次将各结点插入到链表的前端		时间复杂度：O(n)
						
							void CreateList(LinkList &L,int n){
								L = new LNode;
								L -> next = NULL;				内存当中开辟一块空间将地址赋值给头结点
								for(i = n;i > 0;--i){
									p = new LNode;
									cin >> p -> data;			创建新结点将新节点数据输入至数据域
									p -> next = L -> next;			后面节点接在新结点后面
									L -> next = p;				新节点接在头结点后面
								}
							}															

							尾插法：从空表开始，将新节点逐个插入到链表的尾部		时间复杂度：O(n)

							void CreateList(LinkList &L,int n){
								L = new LNode；	
								L -> next = NULL;				建立头结点，内存分配空间，指针域设置为空
								r = L；						单节点，头指针表示尾指针								
								for(i = 0;i < n;++i){
									p  = new LNode;				创建新节点，设置数据域值和指针域
									cin >> p -> data;
									p -> next = NULL;
									r -> next = p;				将新节点地址赋值给尾指针
									r = p；					r指向新尾结点
								}


				循环链表：首尾相接的链表
					优点：从表中任意结点均可找到其他结点
					
					非空循环链表(表中最后一个结点的指针域指向头结点)		时间复杂度O(1)
						结构示意图：
							←	←	←	←	←	←	←	  ←
							- head(头指针) -> data|next -> data|next -> ... -> data|R -

					空循环链表(头结点的指针域指向头结点自身)
						结构示意图：
							←	←
							- ^|next -			头结点数据域为空，头指针指向头结点地址
					
					判断循环链表终止条件：判断是否等于头指针		
						p != L
						p -> next != L	
 
					补充：循环链表的操作通常实在首尾位置进行
					尾指针表示单循环链表：
						头结点的存储位置：R -> next
						尾结点的存储位置：R

					C实现带尾指针循环链表的合并(Tb合并在Ta之后)：				
						思路：	p存表头结点		p = Ta -> next;
							Tb表头连接到Ta表尾		Ta -> next = Tb -> next -> next	
							释放Tb表头结点		delete Tb -> next;
							修改指针			Tb -> next = p;
							
						LinkList Connect(LinkList Ta, LinkList Tb){		时间复杂度:O(1)
							p = Ta -> next;
							Ta -> next = Tb -> next -> next;
							delete Tb -> next;
							Tb -> next = p;
							return Tb;
						}


				双向链表(Double Linked List)：链式存储结构中，结点包含两个指针域
					双链表存储结构：前驱指针域|数据域|后继指针域		prior|data|next
					prior(前驱指针域)：存放该结点前驱结点的地址
					next(后继指针域)：存放该结点后继结点的地址
					data(数据域)，存放数据元素自身的信息	
							
					单循环链表结构示意图：
						带头结点：	head(头指针) -> ^|data|next <-> prior1|data1|next1 <-> prior2|data2|next2 <-> ... <-> priorn|datan|^	
						不带头结点	head(头指针) -> ^|^|^
					
					双循环链表结构示意图：
						带头结点：		    <-		       <-		   <-	   <-		     <-
								head(头指针) -> prior|data|next <-> prior|data|next <-> ... <-> prior|data|R  ->
						空双向循环链表：	
								head(头指针) -> ^|^|^

					双向循环链表特性(假设指针p指向双循环链表某一结点)
						p -> prior -> next = p = p -> next -> prior		前驱结点的后继指针域 = 后继结点的前驱指针域
							
						
					双向链表结构定义：
						typedef struct DoubleLink{
							Elemtype data；
							struct DoubleLink *prior，*next；		*prior/*next指向的仍然是结点
						}DoubleLink，*DoubleLink；				*DoubleLink：指向双向链表结点的指针
						
					C实现双循环链表的插入删除：		插入删除需要同时修改两个方向上的指针，时间复杂度：O(n)
						在第i个结点前插入值为e新结点：
							void ListInsert(DoubleLink &L,int i,ElemType e){
								if(!(p = GetElem(L,i))){
									return ERROR;
								}
								s = new DoubleLink;			设置插入新结点
								s -> data = e;
								s -> prior = p -> prior;			修改指针指向
								p -> prior -> next = s;
								s -> next = p;
								p -> prior = s;
								return OK;
							}

						双向链表的删除：
							void deleteElem(DoubleLink &L,int i,ElemType &e){
								if(!(p = GetElem(L,i))){
									return ERROR;
								}	
								e = p -> data;
								p -> prior -> next = p -> next;			
								p -> next -> prior = p -> prior;
								free(p);					释放p结点内存空间
								return OK;		
							}	
				
			顺序表与链式表比较：
				链式存储结构优缺点：
					优点：	结点空间可以动态申请和释放
						插入和删除时候不需要移动数据元素
						
					缺点：	存储密度小，每个结点的指针域额外占用存储空间				补充：存储密度 = 结点数据本身占用空间/结点占用的空间总量
						非随机存取，对任意结点的操作都要从头指针依指针链查找到该结点，时间复杂度O(n)

				顺序存储结构：
					优点：	随机存取，通过索引在O(1)时间内访问任何元素,时间复杂度O(1)
				
					缺点：	插入和删除元素时，需要移动大量元素
						预先分配固定大小的内存空间，可能造成内存浪费


				
	栈和队列(特殊线性表)：	
		栈/队列逻辑结构和物理结构：
			逻辑结构：与线性表相同，存在一对一关系，所有结点最多存在一个直接前驱和直接后继
		
			物理结构：
				顺序存储结构(顺序栈/顺序队)：用一组连续的存储单元依次存放栈(从栈底到栈顶)/队列的数据元素
				
				链式存储结构(链栈/链队)：用一组任意地址的存储单元来依次存放栈/队列的数据元素

		栈(Stack)：	先进后出(LIFO)，是限定仅在一端(栈顶)进行插入和删除操作的线性表

		|		| 栈顶Top	基本概念：
		|  元素4	|			栈顶(Top):允许插入和删除的一端(水平面)
	出栈  ↑	|  元素3	| ↓ 入栈			栈底(Base):栈顶的另一端
		|  元素2	|			空栈：栈中没有任何元素	
		|  元素1	| 栈底Base		入栈/压入(Push)：插入元素到栈顶
						出栈/弹出(Pop)：从栈顶删除一个元素		
						上溢：栈已满，还要压入元素
						下溢：栈已空，还要弹出元素
			
			C实现栈基本操作：	
				条件：	附设top指针，指示栈顶元素上的一个元素在顺序栈中的位置		
					附设base指针，指示栈底元素在顺序栈中的位置			
					stacksize表示栈可使用的最大容量	

					补充：	空栈	top = base
						入栈	top = top + 1
						出栈	top = top - 1
						栈满	top = stackize - 1
							top - base = stacksize(top/base都是同一数组中的指针)	
				栈顺序表示及实现：				    
					定义顺序栈：
						#define MAXSIZE 100；
						typedef struct SqSatck{
							StackElemType *base；				栈底指针
							StackElemType *top；				栈顶指针
							int stacksize；					栈可用最大容量
						}SqStack
					
				
					顺序栈初始化：		
						Status InitStack(SqStack &S){			构造一个空栈
							S.base = new StackElemType[MAXSIZE]；	为顺序栈动态分配一个最大容量为MAXSIZE的数组空间
							if(!S.base) exit(OVERFLOW);		存储空间分配失败
							S.top = S.base;				top初始为base，空栈
							S.stacksize = MAXSIZE;			stacksize置为栈的最大容量
							return OK;
						}

					判断顺序栈是否为空：
						Status StackEmpty(SqStack S){
							if(S.top == S.base){			如果栈顶  = 栈底，栈为空
								return TRUE;
							}else{
								return FALSE;	
							}
						} 

					求顺序栈长度：
						int StackLength(SqStack S){
							return S.top - S.base;			栈长 = 栈顶 - 栈底
						}

					清空顺序栈：
						Status ClearStack(SqStack S){
							if(S.base){				
								S.top = S.base;			栈底为空，栈顶设置为栈底
								return OK;
							}
						}

					销毁顺序栈：
						Status DestoryStack(SqStack &S){
							if(S.base){
								delete S.base;
								S.stacksize = 0;
								S.base = S.top = NULL;
							}
							return OK;
						}

					顺序栈入栈：
						思想：	判断是否满栈，上溢报错
							元素e压入栈顶
							栈顶指针加1

						Status Push(SqStack &S，StackElemType e){
							if(S.top - S.base == S.stacksize){
								return ERROR;
							}
							*S.top++ = e;				元素e压入栈顶，栈顶指针加1
							return OK；
						}	

							补充：*S.top++ = e; <==> *S.top = e;  S.top++;
					
					顺序栈出栈：
						思想：	判断是否栈空，下溢报错
							获取栈顶元素e
							栈顶指针减1

						Status Pop(SqStack &S,StackElemType &e){	
							if(S.top == S.base){
								return ERROR;
							}
							e = *--S.top;
							return OK;
						}
							
							补充：e = *--S.top; <==> --S.top;  e = *S.top;

				栈链式表示及实现：		插入和删除在栈顶处执行
					链栈结点结构：数据域|指针域 <==> data|next			补充：链栈不需要头结点
					定义链栈结点：
						typedef struct StackNode{
							StackElemType data;			数据域
							strcut StackNode *next；			指针域
						}StackNode,*LinkStack;

					链栈的初始化：	构造一个空栈，栈顶置为空
						void InitStack(LinkStack &S){
							S = NULL;
							return OK;
						}
					

					判断链栈是否为空：
						Status StackEmpty(LinkStack S){
							if(S == NULL){
								return TRUE;
							}else{
								return FALSE;
							}
						}

					链栈的入栈：						补充：头指针命名单链表
						Status Push(LinkList &S,StackElemType e){
							p = new StackNode;			创建插入结点，赋值
							p -> data = e;				
							p -> next = S;				
							S = p;					修改栈顶指针
							return OK;
						}

					链栈的出栈：
						Status Pop(LinkStack &S,StackElemTYpe &e){
							if(S == NULL){
								return ERROR;
							}
							e = S -> data;				e存储删除结点数据域的值
							p = S；					记录删除结点
							S = S -> next;				修改栈顶指针
							delete p；				删除结点空间
							return OK；
						}
					
					取栈顶元素：
						StackElemType GetStackTop(LinkList S){
							if(S != NULL){
								return S -> data;
							}
						}
						
			栈的递归：
				递归：一个过程(或函数)直接或间接地调用自身
			
				递归使用场景：
					递归定义的数学函数		函数当中调用函数
					递归特性的数据结构		二叉树
					递归求解的问题		分治法：对于复杂问题分解成相对简单且解法相同的子问题求解					
					

		队列(Queue)：	先进先出(FIFO),是限定在表一段进行插入，在另一端进行删除的线性表
		    ← 队尾入栈
		______________		基本概念：
		元  元  元			队尾：允许插入的一端
		素  素  素  .....		对头：允许删除的一端
		1   2   3			入队：从队尾插入元素的操作
		______________			出队：从队头删除元素的操作
		    → 队头出栈			循环队列：头尾相接的顺序存储结构，允许队列直接从数组中下标最大的位置延续到下标最小的位置
				
			C实现队列基本操作：
				普通队列常见操作：
					初始	front = rear = 0
					入队	base[rear] = x;					将数据元素存放在数组尾指针
						rear++;						rear + 1
					出队	x = base[front]；				返回头指针指向的存储单元元素
						front++；					front + 1
					空队	front == rear；
					
					补充：
						真溢出：	front = 0；	rear = MAXQSIZE；
						假溢出：	front != 0;	rear = MAXQSIZE;	改进：循环队列
	
				循环队列表示及实现：用一维数组base[MAXQSIZE]表示
					定义循环队列：	
						#define MAXQSIZE 100				队列最大长度
						Typedef struct{
							QueueElemType *base；			
							int front；				头指针
							int rear；				尾指针
						}SqQueue；				

						注意：*SqQueue指针类型引用成员	->
						     SqQueue普通类型引用成员	.

					循环队列初始化：
						Status InitQueue(SqQueue &Q){
							Q.base = new QueueElemType[MAXQSIZE];			分配数组空间	
							if(!Q.base){
								exit(OVERFLOW);					分配存储空间失败
							}	
							Q.front = Q.rear = 0;					头指针/尾指针置为0
							return OK；
						}

					求队列的长度：
						int getLenght(SqQueue Q){
							return ((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);
						}

					循环队列入队：
						Status PushQueue(SqQueue &Q,QueueElemType e){
							if((Q.rear + 1) % MAXQSIZE == Q.front){			队满报错
								return ERROR;
							}
							Q.base[Q.rear] = e;					将元素e放在尾指针
							Q.rear = (Q.rear + 1) % MAXQSIZE；			rear + 1
							return OK；	
						}

					循环列表出队：
						Status PopQueue(SqQueue &Q,QueueElemType e){
							if(Q.front == Q.rear){					队空报错
								return ERROR;
							}
							e = Q.base[Q.front];					队列不为空，将队头指针所指元素保存
							Q.front  = (Q.front + 1) % MAXQSIZE			front + 1
							return OK；
						}

					取对头元素：
						QueueEelmType GetHead(SqQueue Q){
							if(Q.front != Q.rear){					队列不为空
								return Q.base[Q.front];				返回头指针元素
							}
						}
						
				链队表示及实现：		表头删除元素，表尾插入元素
					链队结点结构：数据域|指针域 <==> data|next

					链队列结构: (Q.front)data1|next1 -> data2|next2 -> ...... -> datan|^(Q.rear)

					定义链队列：
						#define MAXQSIZE 100		
						typedef struct QueueNode{
							QueueElemType data;					数据域
							struct QueueNode *next;					指针域			
						}QueueNode,*QueuePtr;

						typedef struct{							
							QueuePtr front;						队头指针
							QueuePtr rear;						队尾指针
						}LinkQueue；

					链队列初始化：
						Status InitQueue(LinkQueue &Q){		
							Q.front = Q.rear = (QueuePtr)malloc(sizeof(QueueNode));	
							if(!Q.front) exit(OVERFLOW);
							Q.front -> next = NULL;
							return OK;
						}

						解释：
							sizeof(QueueNode)：计算QueueNode结构体类型的大小
							malloc：标准函数库，动态分配内存
							(QueuePtr)：强制类型转换，将返回void*类型转换成QueuePtr类型

					链队销毁：
						Boolean DestoryQueue(LinkQueue &Q) {
    							while (Q.front) {
        							QueueNode *p = Q.front->next;
       		 						delete Q.front;
        							Q.front = p;
    							}
   							 return true;
						}

					链队入队：
						Boolean PushQueue(LinkQueue &Q, int e) {
    							QueueNode *p = new QueueNode;
    							p->data = e;
    							p->next = NULL;
    							Q.rear->next = p;
    							Q.rear = p; 						修改尾指针
    							return true;
						}

					链队出队：
						Boolean PopQueue(LinkQueue &Q, int &e) {
    							if (Q.front == Q.rear){
								return false;					空队报错
							}
    							QueueNode *p = Q.front->next;				p指向队头元素
    							e = p->data;
   							Q.front->next = p->next;				修改头指针
    							if (Q.rear == p){
							 	Q.rear = Q.front;				头结点下一结点就是尾结点时
							}
    							delete p;
    							return OK;
						}

					取链队队头元素：
						Status GetHead(LinkQueue Q,QueueElemType &e){
							if(Q.front != Q.rear){
								return Q.front -> next -> data;
							}else{
								return false;
							}
						}



	串/数组/广义表(线性结构的推广)：	线性结构(存在一对一关系，所有结点最多存在一个直接前驱和直接后继)
	串/字符串(String)：
		基本概念：由零个或多个任意字符组成的有限序列，非空串记作：S = "a1a2...an"(n >= 0)
				S		串名
				a1a2...an	串值
				n		串长					补充：n = 0(空串)用符号Ø表示

			子串：串中任意个连续字符组成的子序列
			真子串：不包含自身的所有子串	
			主串：包含子串的串
			子串位置：字串第一个字符在主串中的位置
			空格串：由一个或多个空格组成的串
			空串：不包含任何字符
			串相等：当且仅当两个串长度相等且各个对应位置上的字符都相同		补充：所有空串都相等

		串的存储结构：
			逻辑结构：与线性表相同，存在一对一关系，所有结点最多存在一个直接前驱和直接后继

			物理结构：
				顺序存储结构(顺序串)：用一组连续的存储单元依次存放串的数据元素
			
				链式存储结构(链串)：用一组任意地址的存储单元来依次存放串的数据元素

		C实现串基本操作：
			顺序串表示及实现(实际常用)：
				定义顺序串：
					#define MAXLEN 255;					静态分配固定存储空间
					typedef struct{
						char ch[MAXLEN + 1];				存储串的一维数组
						int Length;					串的当前长度
					}SString；				
					
			链串表示及实现：
				链串结点结构：数据域|指针域 <==> data|next
				
				链串结构：head -> data1|next1 -> data2|next2 -> data3|next3 -> ... -> datan|^		一个data存储一个char
				块链串结构：head -> data1[]|next1 -> data2[]|next2 -> ... -> datan[]|^
				
				定义块链串：
					#define CHUNKSIZE 80
					typedef struct Chunk{
						char ch[CHUNKSIZE];
						struct Chunl *next;
					}Chunk;

					typedef struct{
						Chunk *head;					串的头指针
						Chunk *tail;					串的尾指针
						int curlen;					串的当前长度
					}LString；						字符串的块链结构
					
			串的模式匹配(字串定位函数/Index函数)：
				模式匹配：确定主串中所含子串第一次出现的位置，找到，匹配成功；没找到，匹配失败

				模式匹配算法：BF算法/KMP算法
					
				***	BF算法(穷举法)：
						思路：将S主串第n个字符开始与子串第一个字符比较，相等逐个比较后续字符，不相等从主串下一个字符，重新与子串第一个字符比较
						     每个字符依次与子串T的对应字符相等，匹配成功

						int index(SString S,SString T,int pos){
							int i = pos,j = 1;
							
							while(i <= S.length && j <= T.length){
								if(S.ch[i] == T.ch[j]){				匹配，主串子串依次匹配下一个字符
									++i;				
									++j;
								}else{						不匹配，主串子串指针回溯开始下一次匹配
									i = i - j + 2;
									j = 1; 
								}	
							}
							if(j >= T.length){					j后移超过子串长度，成功匹配
								return i - T.length; 				返回匹配第一个字符下标(i - 子串长度)
							}else{
								return 0;
							}
						}

						BF算法最好时间复杂度：O(m)			匹配子串长度就匹配到了
						BF算法最坏总次数：(n - m + 1) * m 		若m(子串) << n(主串),算法时间复杂度O(n*m)
						BF算法平均时间复杂度：O(n*m)
					
					KMP算法(主串指针不回溯，子串指针回溯)：		
						next[j]函数:子串中第j个函数与主串中相应字符"失配"，子串中重新与主串中字符进行比较的位置
						补充：子串"失配"字符之前的字符与主串字符"适配"
				
							i(指针)
						S(主串)：a b a b c a b c a c b a b
						T(子串)：a b c a c				可见子串第三个字符(a/c)不同，j直接移动到不同位置
							j(指针)
						
						第一次比较：
							    i(指针)
						S	a b a b c a b c a c b a b
						T	    a b c a c				可见子串第五个字符(b/c),且比较位置前一个字符在子串中有相同字符，j指针右移
							    j(指针)

						第二次比较：
								    i(指针)
						S	a b a b c a b c a c b a b
						T	          a b c a c
								    j(指针)

						void Index_KMP(SString S, SString T, int pos){
    							i = pos; j = 1;
    							while( i <= length(S) && j <= length(T)){
        							if(j == 0 || S[i] == T[j]){
            								++i;
            								++j;
        							}else{
            								j = next[j];
        							}
    							}
    							if (j > length(T)){
    								return i - length(T);
    							}
   							else return 0;
						}



	数组和广义表(线性结构的扩展):
	数组(随机存取结构):		随机存取结构：数组可以通过下标索引在O(1)时间内找到任一指定的元素
		基本概念：
			数组：按一定格式排列的具有相同数据类型的数据元素的集合	
			下标：数组中的每个数据元素的序号

			一维数组：线性表中的数据元素为非结构的简单元素
			一维数组逻辑结构：线性结构
			一维数组声明格式：	
				数据类型 变量名称[长度]；					例：int a[5];

				数据元素：a1 = a[1]
					
				定义一维数组：
					typedef elemtype array[n]；


			二维数组：一维数组中的数据元素又是一维数组结构
			二维数组逻辑结构：
				非线性结构：每一个数据元素即在一个行表中，又在一个列表中
				线性结构(定长线性表)：该线性表的每个数据元素也是定长的线性表
			二维数组声明格式：
				数据类型 变量名称[行数][列数]；				行编号：0-n/列编号：0-m
				
				数据元素：a12 = a[1][2]

				定义二维数组：			
					typedef elemtype array[n];			一维数组中嵌套一维数组
					typedef array array1[m];
				
					或者
				
					typedef elemtype array[m][n];			C语法直接定义二维数组


			n维数组定义：n - 1维数组中的元素是一维数组

		数组的存储结构(顺序存储结构)：		数组一旦建立，数组元素个数和数据元素间的关系不变，一般采用顺序存储结构
			问题：如何将多维数组映射到一维数据元素存储单元地址？

			一维数组存储：
				a[i]存储位置：
						 LOC(0) = a,			i = 0
					LOC(i) = 				
					 	 LOC(i - 1) + L = a + i * L,	i > 0

			二维数组存储：
				行优先存储(以行序为主)：
					将数据元素按行排列，第i + 1个行向量紧接在第i个行向量后面
					a[4,3]存储顺序：a11，a12,a13,a14,a21,a22,a23,a24,a31,a32,a33,a34

					a[i][j]存储位置：LOC(i,j) = LOC(0,0) + LOC(n * i + j) * L				补充：L为每个数据元素的存储单元

				列优先存储(以列序为主)：
					将数据元素按列排序，第j + 1个列向量紧接在第j个列向量后面
					a[4,3]存储顺序：a11，a21，a31，a12，a22，a32，a13，a23，a33，a14，a24，a34	
			
			三维数组存储(行列页)：
				a[m1][m2][m3]各维元素个数为：m1，m2，m3
				a[i,j,k]存储位置：LOC(i,j,k) = a + i * m2 * m3(第i页总元素个数) + j * m3(第i页的第j行总元素个数) + k(第j行第k列元素个数)
								
		矩阵的压缩存储：
			矩阵：一个由m × n个元素排成的m行n列的表				|a11 a12 ... a1n|
			矩阵常规存储：描述成二维数组						|a21 a22 ... a2n|
											|... ... ... ...|
											|am1 am2 ... amn|

			特殊矩阵(对称矩阵，对角矩阵，三角矩阵，稀疏矩阵)：值相同的元素很多或零数据元素在矩阵分布有一定规律		
			特殊矩阵压缩存储：
				为多个值相同的非零数据元素分配一个存储空间
				不为零数据元素分配存储空间

				对称矩阵：在n × n的矩阵a中，数据元素满足aij = aji(i >= 1,j <= n)
					存储方法：只存储三角(包括主对角线)的数据元素
					存储单元总数：n(n + 1)/2
					行优先存储aij与下标k的关系：k = i(i - 1)/2 + j - 1	
															
				对角矩阵：在n × n的矩阵中，所有非零元素都集中在以对角线为中心的区域，区域外的值全为0
					存储方法：行优先存储非零数据元素
					行优先存储aij与下标k的关系：k = 2i + j
				
				三角矩阵：对角线以下(或者以上)的数据元素(不包括对角线)全部为常数c
					存储方法：重复元素c共享一个元素存储空间
					存储单元总数：n(n + 1)/2 + 1
					行优先存储aij与下标k的关系(等差数列求和)：	
						上三角矩阵：
							k = (i - 1) × (2n -i + 2)/2 + j - i + 1		i <= j
							k = n(n + 1)/2 + 1				i > j
						
						下三角矩阵：
							k = i(i - 1)/2 + j				i >= j
							k = n(n + 1)/2 + 1				i < j
				
				稀疏矩阵：在m × n的矩阵中有s个非零数据元素，另t = s/(m × n)，t为矩阵的稀疏因子，当t <= 0.05时，称为稀疏矩阵
					确定矩阵非零元素：三元组(元素行i,元素列j,元素值aij) + 矩阵维数(行数n，列数m)
					
					三元组线性表(顺序存储结构)：						
						例子：	i	j	v(value)				
							6	6	6		"总体"信息		
							1	2	12				|0  12 9  0  0  0|
							1	3	9				|0  0  0  0  0  0|
							3	1	-3		========>	|-3 0  0  0  14 0|
							3	5	14				|0  0  24 0  0  0|
							4	3	24				|0  18 0  0  0  0|
							5	2	18				|0  0  0  0  0  0|

						补充：通常三元组线性表加上"总体"信息(总行数,总列数，非零元素总个数)
						     不能随机存取，需要从头开始查找

					十字链表(链式存储结构)：		结点表示非零元素
						结点结构示意图：
							| 行  | 列 |  值	 |
							|  down	|  right |

							right：用于连接同一行中下一个非零元素
							down：用于链接同一列中下一个非零元素



	广义表(列表Lists):		可以兼容线性表，数组，树，有向图等数据结构	
		基本概念：
			广义表：n >= 0个元素a0，a1，...，a(n-1)的有限序列，成员ai可以是数据元素，也可以是广义表。一般记作：
					LS = (a0,a1,...,a(n-1))

				例如：(巴西，阿根廷，美国，()，(国家队，山东鲁能，广州恒大))

				直接数据元素：巴西，阿根廷，美国
				广义表：(国家队，山东鲁能，广州恒大)/(巴西，阿根廷，美国，()，(国家队，山东鲁能，广州恒大))
			
			空表：广义表中没有元素					
			表头：广义表非空时第一个元素(数据元素/子表)			
			表尾：广义表除去表头其余元素组成的广义表
			长度：广义表最外层包含元素个数
			深度：广义表中括号的最大嵌套层数				补充：一般用大写字母表示广义表，小写字母表示原子

			广义表性质：
				线性结构：有一个直接前驱和一个直接后继
				多层次结构：广义表的元素可以是单元素，也可以是子表，子表的元素还可以是子表
				共享性：广义表及广义表的数据元素可以被其他广义表共享	B = (A)
				递归性：广义表可以是自身的子表			F = (a,F)		
					补充：递归表的深度是无穷值，长度是有限值

			特殊广义表举例：
				LS = ()				长度为0，空表，深度为1
				LS = (())			长度为1，表头表尾为(),深度为2
				LS = (a,(b,c))			长度为2，由原子a,子表(b,c)组成，表头为a，表尾为((b,c))
				LS = (a,b,c)			长度为3，由原子a/b/c组成，深度为1
				LS = ((C),(D)			长度为2，由两个子表组成，表头(C),表尾(D)
				LS = (a,LS)【共享广义表】		长度为2，第一项原子，第二项广义表自身	

		广义表基本运算：
			SL = (E,F) = ((a,(b,c)),F)						
			获得表头:	GetHead(SL) = E			GetHead(E) = a			GetHead((b,c)) = b		GetHead(((b,c))) = (b,c)
			获得表尾:	GetTail(SL) = (F)		GetTail(E) = ((b,c))		GetTail((b,c)) = c		GetTail(((b,c))) = ()
		
				注意：表尾一定是广义表

		广义表的存储结构(链式存储结构)：
			链表结点结构：	
				表结点(存储广义表)		tag = 1|hp|tp
				元素结点(存储数据元素)	tag = 0|data

				tag = 1		tag标志域，标志为1，结点为表结点
				tag = 0		tag标志域，标志为0，结点为数据元素结点
				hp 		指向表头结点的指针
				tp		指向表尾结点的指针
				data		存储数据元素自身的信息
				
		
		
非线性结构：一个结点可能有多个直接前驱和直接后继
树：
	树：
		基本概念：树是n(n >= 0)个结点的有限集
				若n = 0，是空树
				若n > 0,满足两个条件：
					1.有且仅有一个特定的根节点(root)，只有后继结点，没有前驱结点
					2.其余结点可以分为m(m > 0)个互不相交的有限集合T1，T2，T3... 其中每个集合又是树，称为树的子树
			可以记作：	
					Ø				n = 0
				T = 		
					{root，T1，T2，T3...，Tm}		n > 0
											
			树示例：									结点的层次
							A					第1层
					↓		↓		↓
					B		C		D			第2层
				    ↓       ↓          	↓	   ↓	↓    ↓
				    E       F		G	   H	I    J			第3层
				 ↓     ↓			   ↓
				 K     L			   M				第4层(树深)

				子树(不相交的有限集合)：
					T1：{B，E，F，K，L}			子树中仍然有树(递归定义)
					T2：{C，G}
					T3：{D，H，I，J，M}

		基本术语：
			结点：树种数据元素 + 分支
			根结点：非空树中无前驱结点的结点
			叶子结点(终端结点)：没有子树的结点
			分支结点(非终端结点)：含有子树的结点			内部结点：除根结点以外的分支结点
			孩子结点：结点子树的根结点
			双亲结点：孩子结点的上一级结点
			堂兄弟结点：树中位于同一层的结点/双亲位于同一层的结点
			祖先结点：从根节点到该结点所经分支上所有结点
			子孙结点：以某节点为根的子树中的任意结点
			兄弟结点：同一双亲的所有结点

			结点的度：结点拥有的子树(孩子)的个数
			树的度：树内所有结点度的最大值
			树的深度：树中结点的最大层次

			有序树：树中结点的各子树从左到右有次序(最左边是第一个孩子)
			无序树：树中结点的各子树无次序
			森林：m(m >= 0)棵互不相交的树的集合			例：森林：{T1，T2，T3}	

			注意：
				给森林的各子树加双亲结点，森林变成树		树一定是森林，森林不一定是树
				树是特殊的森林

		树的存储结构：
			树的顺序存储结构(双亲表示法)：用一组连续的存储空间存储树的各个结点(数据域 + 双亲域)
				数据域：存放结点本身信息
				双亲域：结点的双亲结点在数组中的位置

				一般树：					双亲表示法：	
						a			     数组下标	data		parent
										0	a		-1
					b		c			1	b		0
										2	c		0
				    d       e		     f			3	d		1
										4	e		1
					 g  h  i				5	f		2
										6	g		4		
					结点结构：data|parent			7	h		4	
					缺点；找双亲容易，找孩子难			8	i		4
													
										补充：-1表示结点没有双亲，其他值表示结点双亲在数组中的位置

			树的链式存储结构：
				孩子链表表示法：用一组连续的存储空间存储树的各个结点(data + firstchild(指针指向孩子结点组成的单链表(单链表结点：child|next)))
					data：存放结点的数据信息
					firstchild：指针指向该结点的孩子结点组成的单链表表头
						单链表结点：
							child：存放孩子结点在一维数组的序号
							next：指向下一个孩子结点

				一般树：					孩子链表表示法：		
						a			    数组下标 	[parent]	data	firstchild
										0	-1		a	单链表表头    ->	1|下一孩子指针 -> 2|^
					b		c			1	0		b	单链表表头    ->	3|下一孩子指针 -> 4|^
										2	0		c	单链表表头    ->	5|^
				    d      e 		     f			3	1		d	^
										4	1		e	单链表表头    ->	6|下一孩子指针 -> 7|下一孩子指针 -> 8|^
					g  h  i					5	2		f	^
										6	4		g	^
				缺点：找孩子容易，找双亲难				7	4		h	^
										8	4		i	^
						
										补充：加上parent即为双亲孩子表示法
				
				二叉链表表示法(二叉树表示法)：以二叉链表作为树的存储结构，链表中每个结点的两个指针域指向第一个孩子结点和该节点兄弟结点					
					
				一般树：					二叉链表表示法：			
						R							A指针|R|^
													D指针|A|B指针
					A       B	C					^|D|E指针	^|B|C指针		
														
				     D     E		F					^|E|^		F指针|C|^
														
						     G	H  K							G指针|F|^
														
					结点结构：firstchild|data|nextsibling					^|G|H指针

		树和森林的遍历：											^|H|K指针
			树遍历：
				先根遍历：若树不为空，先访问根结点，依次先根遍历各棵子树					^|K|^
				后根遍历：若树不为空，先依次后根遍历各棵子树，然后访问根结点
				层次遍历：若树不为空，自上而下从左往右依次访问树中每个结点

				一般树：				遍历：
					A				先根遍历：A B C D E
									后根遍历：B D C E A
				B	C	E			层次遍历：A B C E D
			
					D

			森林遍历：
				森林构成：
					1.森林中第一棵树的根结点(B)
					2.森林中第一棵树的子树森林(E-F)
					3.森林中其它树构成的森林(剩余结点)
				
				遍历方式：
					先序遍历(对森林中所有树依次进行先序遍历)：
						若森林不为空，访问森林中第一棵树的根结点
						先序遍历森林中第一棵树的子树森林
						先序遍历森林中(除第一棵树之外)其余树构成的森林

					中序遍历：
						若森林不为空，中序遍历森林中第一棵树的子树森林
						访问森林中第一棵树的根结点
						中序遍历森林中(除第一棵树之外)其余树构成的森林

				森林：						遍历：
					B	     C		D			先序遍历：B E F C D G H I J K
											中序遍历：E F B C I J K H G D 
				    E	    F			G
					
								H	
								
							    I	J   K	
														
														
	二叉树引言：												
		多叉树(普通树)不转换为二叉树，运算很难实现												
		任何树和森林都可以转换为唯一二叉树									
		任何树和都可以与二叉树相互转换

	二叉树：		
		基本概念：二叉树T是n(n >= 0)个结点的有限集
				若n = 0，是空树
				若n > 0，由一个根结点和两棵互不相交的分别称为根的左子树和右子树的二叉树组成		
			可以记作：
					Ø				n = 0
				T = 
					{root，Tl，Tr}			n > 0
			
			root		根结点
			Tl		左子树
			Tr		右子树		

		特点：
			1.每个结点最多有两棵子树，分别是左子树和右子树
			2.二叉树子树有左右之分，次序不能颠倒
			3.二叉树可以是空集合，根可以有空的左子树或空右子树			
				
			补充：二叉树不是树的特殊情况，二叉树分左右，普通树不分
				
			特点2：		A	A		A		树：	A
									
				    B		    C	    B       C			B

		性质：
			1.在二叉树的第i层上最多有2^(i-1)个结点(i >= 1)			补充：第i层上最少有1个结点
				1	2	3	4	...	n
				1	2	4	8	...	2^(n-1)
				
			2.深度为k(k >= 1)的二叉树最多有2^k - 1				补充：最少有k个结点
				1	2	3	4	...	n
				1(2^0)	2(2^1)	4(2^2)	8(2^3)	...	2^(n-1)		

				求和：等比数列求和公式

			3.对任意二叉树T，若其叶子数为n0，度为2的结点数为n2，则n0 = n2 + 1	
				n：总结点数	n2：度为2的结点数		n1：度为1的结点数
				
				边数B与结点关系：	
					B = n - 1			从下往上，一个结点对应一条边，去除根结点
					B = n2 * 2 + n1 * 1		从上往下，度为2两条边，度为1一条边，叶子结点没有边

				总结点数：	
					n = n2 + n1 + n0	
				
				关系式：	
					n - 1 = B = n2 * 2 + n1 * 1
					n2 + n1 + n0 - 1 = n2 * 2 + n1
					n0 = n2 + 1


		形式：		
			满二叉树(性质2)：深度为k且有2^k - 1个结点的二叉树							A
				特点：										
					1.每一层上的结点数都是最大结点数				    	    	B		C
					2.叶子结点全部在最下层					  
													    E       F	    G	    H	
					补充：	满二叉树在同样深度的结点个数最多
						满二叉树在同样深度的二叉树中叶子结点个数最多		      	  I   J   K   L   M   N   O    P
						满二叉树又是完全二叉树
				
				编号规则：自上而下，自左而右

			完全二叉树：深度为k，具有n个结点，其每一个结点都与深度为k的满二叉树中编号为1 ~ n的结点一一对应
				特点：											A			
					只有第k层是满结点或从右向左连续缺失若干结点
					叶子结点分布在层次最大的两层							B		C
					对任一结点，若右子树最大层次为i，左子树最大层次为i或i + 1
													    E	    F	    G       H
					例：	C(根结点)	左子树：G-M	右子树：H
													  I   J   K   L   M   	
				性质：
					1(结点与深度关系).具有n个结点的完全二叉树的深度为[log2n] + 1				注：[x]，称作x的底，取不大于x的最大整数
							
						假设具有n个结点的完全二叉树深度为k
						n结点的最小值为：2^(k - 1) - 1 			第k层第一个
						n结点的最大值为：2^k - 1				第k层最后一个

						2^(k - 1) - 1 < n <= 2^k - 1
						2^(k - 1) <= n < 2^k	
					取对数	k - 1 <= log2n < k
					k为整数	k = [log2n] + 1	

					2(双亲编号与孩子编号关系).如果有一棵n结点的完全二叉树(深度为[log2n] + 1)的结点按层序编号(从第1层到第[log2n] + 1 层，每层从左到右)，
					 则对任一结点(1 <= i <= n),有：
						1.如果i = 1，则结点i是二叉树的根，如果i > 1，则其双亲结点是[i/2]
						2.如果2i >  n,则结点i为叶子结点，无左孩子；否则，其左孩子是结点2i
						3.如果2i + 1 > n,则结点i无右孩子；否则，其右孩子是结点2i + 1
			
			研究线索二叉树原因：用二叉链表作为二叉树的存储结构，可以直接找到某结点的左右孩子，但无法找到该结点在某遍历序列中前驱和后继结点
			线索二叉树：
				定义：	如果某个结点的左孩子为空，将空的左孩子指针改为前驱结点指针
				     	如果某个结点的右孩子为空，将空的右孩子指针改为后继结点指针

				基本概念：
					线索：指向前驱结点和后继结点的指针
					线索二叉树：加上线索的二叉树
					线索链表：加上线索的二叉链表
					基本概念：对二叉树按某种遍历次序使其变为线索二叉树的过程(先序/中序/后序线索二叉树的过程)

				线索二叉树结点结构示意图：
					lchild|ltag|data|rtag|rchild

					ltag = 0 	lchild指向该结点的左孩子
					ltag = 1 	lchild指向该结点的前驱结点
					rtag = 0	rchild指向该结点的右孩子
					rtag = 1 	rchild指向该结点的后继结点

				一般二叉树：					二叉链表：					中序线索二叉树：
							A					B指针|A|^					B指针|A|^(A后继)
					
						B					C指针|B|D指针					C指针|B|D指针
					
					   C	     D				^|C|^		E指针|D|F指针		  (C前驱)^|C|B(C后继)	   E指针|D|F指针	
				
						  E	F				   ^|E|G指针	^|F|^				(E前驱)B|E|G指针   (F前驱)D|F|A(F后继)

						    G						^|G|^					    (G前驱)E|G|D(G后继)
					
					中序遍历：C B E G D F A

				一般二叉树：					二叉链表：					先序线索二叉树：
							A					  B指针|A|D指针					B指针|0|A|0|D指针
			
						B		D			^|B|C指针		E指针|D|^	A指针|1|B|0|C指针			E指针|0|D|1|E指针
						
						    C	    E				       ^|C|^	     ^|E|^		     B指针|1|C|1|E指针	  B指针|1|E|1|^

					先序遍历A B C D E

				C实现线索二叉树结点结构：
					typedef struct BiThrNode{
						int data；
						int ltag，rtag；
						struct BiThrNode *lchild，rchild；
					}BiThrNode，*BiThrNode；
					
					
		存储结构：
			顺序(数组)存储：用一组连续的存储单元按满二叉树的结点层次编号，依次存放二叉树中结点的值			补充：结点编号与结点的值是不同的概念
				一般二叉树顺序存储：
							A(编号：0)  

						B(编号：1)  	C(编号：2)

				     (编号：3)D	   E(编号：4) (编号：5)	(编号：6)		顺序存储：A B C D E 0 0 0 0 F G
													0 1 2 3 4 5 6 7 8 9 10
					   7   8 F(9) G(10)		
						
					方法：增加不存在的空结点并按顺序进行编号处理，再按一维数组进行存储

					缺点：		A
								B
									C
										D		数组定长，大量空结点造成空间浪费

			链式存储(常用)：
				二叉链表：lchild|data|rchild
					lchild：左指针域，存放指向左孩子的指针，当左孩子不存在时为空指针
					data：数据域，存放该结点自身的数据
					rchild：右指针域，存放指向右孩子的指针，当右孩子不存在时为空指针 
					
					一般二叉树二叉链表结构：
								A				链式存储：(head) -> B指针|A|^ 
	
							B						C指针|B|D指针

						   C         D					^|C|^			E指针|D|F指针
								
							 E       F						^|E|G指针		^|F|^
														     
						       	    G	 							^|G|^
												
					补充：n个结点的二叉链表，有(n + 1)个空指针域			补充：头指针(head)指向根节点地址	
						证明：	
							1个二叉结点有两个指针域，n个结点有2n个指针域   
							除根节点，每个结点都有一个双亲，所以有(n - 1)个结点存放指针，指向非空子女结点
							
							2n - (n - 1) = n + 1
							
				三叉链表：lchild|data|parent|rchild
					lchild：左指针域，存放指向左孩子的指针，当左孩子不存在时为空指针
					data：数据域，存放该结点自身的数据
					parent：指向双亲结点的指针域
					rchild：右指针域，存放指向右孩子的指针，当右孩子不存在时为空指针 	

					一般二叉树三叉链表结构：
								A				链式存储：(head) -> B指针|A|^|^ 
	
							B						C指针|B|指针|D指针

						   C         D					^|C|B指针|^			E指针|D|B指针|F指针
								
							 E       F						^|E|D指针|G指针		^|F|D指针|^
														     
						       	    G	 							^|G|E指针|^

		遍历二叉树：
			目的：得到树中所有结点的线性序列
			定义：顺着某一条搜索路径访问二叉树的各个结点，使各个结点均被访问一次，而且仅被访问一次(周游)   
				访问：输出结点信息，修改结点数据值
						
			D：访问根结点		L：遍历左子树		R：遍历右子树			
			遍历方式(递归遍历)：		根据根结点的位置判断先后
				遍历规则：遍历先判断子树是否为空，不为空，再进行遍历
				先序遍历(DLR):	
						D(1)			注意：编号代表遍历顺序
					L(2)		R(3)		根 - 左子树 - 右子树

					先序遍历求遍历顺序：
								A

							B		D
							
						  E		   H	     J
						
					             L	        M    I				
					
					先序遍历顺序：
						根：	A				先序遍历顺序：A B E L D H M I J
											
						左子树：	BEL				
							根：	B				
							左子树：	EL					
								根：	E				
								左子树：	空					
								右子树：	L					
							右子树：	空						
													
						右子树：	DHJMI					
							根：	D				
							左子树：	HMI				
								根：	H			
								左子树：	M
								右子树：	I
							右子树：	J

					先序遍历递归算法：
						Status PreOrderTraverse(BiTree T){
							if(T == NULL) return OK;
							else{
								visit(T);				访问根结点
								PreOrderTraverse(T -> lchild);		递归遍历左子树
								PreOrderTraverse(T -> rchild);		递归遍历右子树
							}
						}
						
						时间复杂度：O(n)/空间复杂度：O(n)

	
				中序遍历(LDR):						
						D(2)			注意：编号代表遍历顺序
					L(1)		R(3)		左子树 - 根 - 右子树

					中序遍历求遍历顺序：
								A

							B		D
							
						  E		   H	     J
						
					             L	        M    I				
					
					中序遍历顺序：
						左子树：	BEL				中序遍历顺序：E L B A M H I D J
							左子树：	EL			
								左子树：	空			
								根：	E			
								右子树：	L				
							根：	B					
							右子树：	空						
														
						根：	A							
													
						右子树：	DHJMI					
							左子树：	HMI		
								左子树：	M			
								根：	H			
								右子树：	I
							根：	D
							右子树：	J

					中序遍历递归算法：
						Status InOrderTraverse(BiTree T){
							if(T == NULL) return OK;
							else{		
								InOrderTraverse(T -> lchild);		递归遍历左子树	
								visit(T);				访问根结点
								InOrderTraverse(T -> rchild);		递归遍历右子树
							}
						}

						时间复杂度：O(n)/空间复杂度：O(n)
												

				后序遍历(LRD):
						D(3)			注意：编号代表遍历顺序
					L(1)		R(2)		左子树 - 右子树 - 根	

					后序遍历求遍历顺序：
								A

							B		D
							
						  E		   H	     J
						
					             L	        M    I				
					
					后序遍历顺序：
						左子树：	BEL				后序遍历顺序：L E B M I H J D A
							左子树：	EL
								左子树：	空		
								右子树：	L			
								根：	E				
							右子树：	空							
							根：	B						
														
						右子树：	DHJMI							
							左子树：	HMI					
								左子树：	M			
								右子树：	I		
								根：	H			
							右子树：	J				
							根：	D
						
						根：	A

					后序遍历递归算法：
						Status PostOrderTraverse(BiTree T){
							if(T == NULL) return OK;
							else{
								PostOrderTraverse(T -> lchild);		递归遍历左子树
								PostOrderTraverse(T -> rchild);		递归遍历右子树
								visit(T);				访问根结点
							}
						}

						时间复杂度：O(n)/空间复杂度：O(n)

				非递归算法实现先序/中序/后序遍历(栈实现)：
					算法思路：
						中序遍历(左子树 - 根 - 右子树)，如何找到根和右子树
						设计一个栈，根据中序遍历规则，先遍历左子树，根结点入栈
						左子树遍历结束(左子树为空/左子树遍历结束)，根结点出栈，输出根结点，遍历右子树
						
					非递归算法实现中序遍历：
						Status InOrderTraverse(BiTree T){				
							BiTree p；
							InitStack(S);					栈初始化
							p = T;						操作变量p，初值是根结点
							while(p || !StackEmpty(S)){
								if(p){
									Push(S,p);			树根结点入栈，访问左子树
									p = p -> lchild;
								}else{
									Pop(S,q)				左子树为空，根结点出栈
									printf("%c",q -> data);
									p = q -> rchild;
								}
							}
							return OK;
						}


				层次遍历：	对一棵二叉树，从根节点开始，按从上到下，从左到右的顺序访问每一个结点，每个结点仅访问一次
					算法思路：	
						将要访问的结点(入队)，已访问完的结点出队
						操作结点指针入队，若该节点左右孩子不为空，将左右孩子指针入队，双亲结点出队(先进先出)；若该节点左右孩子结点为空，结点出队
						出队结点依次得到队列序列，同一层的结点从左到右依次执行

					层次遍历算法:
						typedef struct{
							BTNode data[MaxSize];				存放队列元素
							int front,rear;					对头队尾指针
						}SqQueue；					
						
						void LevelOrder(BTNode *b){
							BTNode *p; 
							SqQueue *qu;					
							InitQueue(qu);					初始化队列
							enQueue(qu,b);					根结点入队
							while(!QueueEmpty(qu)){				队列不为空，开始循环
								deQueue(qu,p)				队头元素出队
								printf("%c",p -> data);			访问结点p
								if(p -> lchild != NULL){
									enQueue(qu,p -> lchild);	结点若有左孩子，左孩子入队
								}
								if(p -> rchild != NULL){
									enQueue(qu,p -> rchild);	结点若有右孩子，右孩子入队
								}
							}
							
						}

			根据遍历序列确定二叉树：
				性质：二叉树的先序序列和中序序列可以确定一棵二叉树

				问题：已知二叉树的先序和中序序列，构造出相应的二叉树
				解决方法：先序序列判断根，中序序列根据根判断左右子树，
					先序：A B C D E F G H I J 		根-左子树-右子树
					中序：C D B F E A I H G J		左子树-根-右子树

					推出:	
						左子树：C D B F E/B C D E F			画图：		A
							左子树：C D		
								根：C					B		G
								右子树：D				
							根：B					    C       E	    H	    J
							右子树：F E
								根：E				      D	  F	 I
								左子树：F
						根：A
						右子树：I H G J/G H I J
							左子树：I H
								根：H
								左子树：I
							根：G
							右子树：J
						
				性质：二叉树的后序序列和中序序列可以确定一棵二叉树
				
				问题：已知二叉树的后序和中序序列，构造出相应的二叉树
				解决办法：后序序列判断根，中序序列根据根判断左右子树
					后序：D E C B H G F A
					中序：B D C E A F H G
					
					推出：
						左子树：D E C B/B D C E				画图：		A
							左子树：空
							右子树：D C E					B		F
								左子树：D
								右子树：E					     C      	    G
								根：C
							根：B						   D   E          H
							
							
						右子树：H G F/F H G
							左子树：H G
								左子树：H
								右子树：空
								根：G
							右子树：空
							根：F
						根：A
	
			二叉树遍历应用(递归算法)：	
				二叉树的建立(利用先序序列构造二叉树):
					算法思路：从键盘输入二叉树的结点，建立二叉树的存储结构
						在建立二叉树的过程中按照二叉树先序方式建立

					已知先序序列：A B C D E G F
					构造二叉树：			A				先序序列不能唯一确定一个二叉树
													输入序列用#补充空结点确定唯一二叉树
								B		#
						
							   C	     D	   
					
						        #     #   E     F
							
								#   G #   #
								 	
								   # #
							
					输入序列：A B C # # D E # G # # F # # #
					算法实现：
						Status CreateBiTree(BiTree &T){
							scanf(&ch);					输入构造序列
							if(ch == "#"){
								T = NULL;				构造序列为空，树为NULL	
							}else{
								if(!(T = new BiTNode)){			不为空，申请二叉链表结点空间
									exit(OVERFLOW);					
								}		
								T -> data = ch;				生成根结点
								CreateBiTree(T -> lchild);		构造左子树
								CreateBiTree(T -> rchild);		构造右子树
							}
							return OK;
						}
				
				复制二叉树：
					算法思路：
						空树，递归结束
						非空，创建新结点，复制根结点，递归复制左子树，递归复制右子树
							
					算法实现：
						int Copy(BiTree T,BiTree &NewT){
							if(T == NULL){
								NewT = NULL;
								return 0;
							}else{
								NewT = new BiTNode;
								NewT -> data = T -> data;
								Copy(T -> lchild,NewT -> lchild);
								Copy(T -> rchild,NewT -> rchild);
							}
						}	

				计算二叉树深度:
					算法思路：
						空树，深度为0
						非空，递归计算左子树深度记作m，递归计算右子树深度记作n，比较m/n取较大值
						二叉树深度 = 较大值 + 1
				
					算法实现：
						int Depth(BiTree T){
							if(T == NULL){
								return 0;
							}else{
								m = Depth(T -> lchild);
								n = Depth(T -> rchild);
								if(m > n){
									return (m + 1);
								}else{
									return (n + 1);
								}
							}
						}	

				计算二叉树结点总数：
					算法思路：
						空树，结点个数为0
						非空，结点个数 = 左子树结点个数 + 右子树结点个数 + 1					

					算法实现：
						int NodeCount(BiTree T){
							if(T == NULL){
								return 0;
							}else{
								return NodeCount(T -> lchild) + NodeCount(T -> rchild) + 1;
							}
						}	

				计算叶子结点总数：
					算法思路：
						空树，叶子结点数为0
						非空，叶子结点数 = 左子树叶子结点数 + 右子树叶子结点数

					算法实现：	 	
						int LeadCount(BiTree T){
							if(T == NULL){
								return 0;
							} 	
							if(T -> lchild == NULL && T -> rchild == NULL){
								return 1
							}else{
								return LeafCount(T -> lchild) + LeafCount(T -> rchild);
							}	
						}
	

	树/森林/二叉树转换：
		树与二叉树转换：		
			树 <-> 二叉链表 <-> 二叉树 	==> 给定一棵树，可以找到唯一的一棵二叉树与之对应
				注意：树采用的二叉链表表示法与二叉树的二叉链表存储结构是完全相同的

			将树转换成二叉树(兄弟相连留长子)：		
				1.加线：在兄弟结点之间加一条线
				2.删线：对每个结点，只保留与第一个孩子结点之间的连线，删除与其他孩子结点之间的连线
				3.旋转：以第一个孩子结点为轴心，将整树顺时针转45度(第一个孩子结点是左子树，其余兄弟结点都在右子树)

				一般树：					加线删线：				旋转：
						A					A					A	
					↓	↓	↓			↓					B
					B	C	D			B-------C-------D		E	    	C
				     ↓  ↓  ↓	      ↓    ↓		     ↓		      ↓			     F		     D
				     E  F  G          H    I		     E--F--G          H---I		        G	 H
																    I	
			将二叉树转换成树(左孩右右是兄弟，去掉原来右孩线)：
				1.加线：p结点是双亲结点的左孩子，将p结点沿最右分支找到的所有右孩子与p结点的双亲结点连起来
				2.删线：删除原二叉树中双亲与右孩子之间的连线
				3.调整：将结点按层次排列，形成树结构
															     
		森林与二叉树转换：									
			将森林转换成二叉树(子树变二叉，二叉相连变森林)：			森林：m棵互不相交的树的集合
				1.将树的子树转换成二叉树
				2.将每棵树的根结点连接起来
				3.以第一棵二叉树的根为轴心，顺时针旋转构成二叉树型结构

				森林：
					A		E		G

				   B 	C    D		F	    H	    I
					
									    J
				转换成二叉树并相连：
					A     ---	E     ---	G
				    B		    F		   H
				      C				      I
					D			    J	

				森林转变成的二叉树
							A
					B	  	E		G
					   C	     F		    H		
					      D		  		I
						    		    J	

			将二叉树转换成森林(去掉全部右孩线，孤立二叉再还原)：
				1.将最右分支的右孩子间连线全部删除，变成独立的二叉树
				2.将独立的二叉树还原成树

				二叉树：
						A
					B	 	E
					    C	    F
					  D	  I   G
						     J H
				
				转换成森林并还原：
						A				E
					B		C		F	G	H
						        D		I	J

		树/二叉树/森林转换注意点：
			树与二叉树：双亲结点左孩子的最右分支全是兄弟
			森林与二叉树：森林的最右分支全是独立二叉树	
				

	哈夫曼树和哈夫曼编码：
		哈夫曼树：
			基本概念：
				路径：从一个结点到另一个结点之间的分支
				结点的路径长度：两个结点间路径上的分支数
				树的路径长度：从根结点到每个结点的路径长度之和，记作：TL			补充:结点数相同，完全二叉树路径长度最短
				结点的权：对结点赋予的一个有某种含义的数值				     
				结点的带权路径长度 = 根结点到该结点之间的路径长度 × 该结点的权		     
				树的带权路径长度：树中所有叶子结点的带权路径长度之和
				哈夫曼树(最优二叉树)：带权路径长度最小的二叉树				
	
			构造哈夫曼树：	
				1.根据n个给定的权值{w1，w2，...,wn}构成n棵二叉树的森林F = {T1，T2，...,},其中Ti只有一个带权wi的根结点
				2.在F中选取两棵根结点的权值最小的树作为左右子树，构成一棵新的二叉树，二叉树根结点权值为左右子树上根结点权值之和		
				3.在F中删除这两棵树，同时将新得到的二叉树加入到森林中
				4.重复2/3步骤，直到森林中只有一棵树

				简化口诀：
					1.构造森林全是根
					2.选用两小造新树
					3.删除两小添新人
					4.重复2，3剩单树

				例：有4个结点a，b，c，d，权值分别为7，5，2，4，构造哈夫曼树
					F = {a(7),b(5),c(2),d(4)}	选用两小造新根		画哈夫曼树：
														g(18)
					F = {a(7),b(5),e(6)}		删除两小添新人		
													a(7)		f(11)
					F = {a(7),f(11)}		删除两小添新人		
														    b(5)	        e(6)
					F = {g(18)}			重复2，3剩单树					
															   c(2)      d(4)
			哈夫曼树特点：
				一组确定权值的叶子结点，可以构造出不同的带权二叉树
				哈夫曼树中权越大的叶子离根越近，满二叉树不一定是哈夫曼树
				每个初始结点都会成为叶子结点
				n个结点的哈夫曼树总结点树为(2n - 1)
				度为2的节点数/产生新结点数为(n - 1)
				没有度为1的结点

		哈夫曼编码：
			条件：	设需要编码的字符集合为{d1,d2,...,dn},它们在电文中出现的次数或频率集合为{w1,w2,...,wn}(频率越大，编码长度越短)
				
			概念：	哈夫曼编码：
					以{d1,d2,...,dn}作为叶子结点，{w1,w2,...,wn}作为它们的权值，构造一棵哈夫曼树。
					规定哈夫曼树左分支代表0，右分支代表1，从根结点到每个叶子结点所经过的路径分支组成的0和1序列便是对应字符的编码
					
				前缀编码：设计不等长编码，必须使任一字符的编码都不是另一个字符编码的前缀	

					补充：	哈夫曼编码，每个字符都是叶子结点，不可能在根结点到其他字符结点的路径上 	==> 哈夫曼编码也是前缀编码
						哈夫曼树的带权路径长度最短，所以哈夫曼字符编码中长最短

				例：求哈夫曼编码
					传输的字符集D = {C，A，S，T，；}	对应字符出现频率w = {2,4,2,3,3}	
					
					画哈夫曼树：
							14				
											
						6		8			  
											  
					    3       3       4       4			   	
					    T       ；	    A				  
								  2    2		  
								  C    S		  

						∵ 左分支为0，右分支为1
						∴ 	T -> 00			编码：	电文：{CAS;CAT;SAT;AT}
						   	；-> 01				编码：11010111011101000011111000011000
						  	A -> 10									
 							C -> 110		解码:	编码：1101000
							S -> 111			电文：CAT


	
图：
	基本概念：有穷非空的顶点集合和顶点之间边的集合，可表示为：G = (V，E)
		V：顶点(数据元素)的有穷非空集合
		E：顶点间边的有穷集合
			
		图示例：
				G1					G2
			V1 ----------->	V2			V1———————V2
			| ↖					|	    /	|
			|     ↖					|	V3	|
			↓	  ↖				|   /	    \	|
			V3 ----------->	V4			V4———————V5
			     有向图				       无向图

		边相关概念：
			邻接：有边/弧相连的两个顶点之间的关系
			无向边：顶点v和w间的边没有方向,记作(v,w),且v/w互为邻接点			v — w
			有向边/弧：顶点v和w间的边有方向,记作<v,w>，且v邻接到w，w邻接于v			v —> w
			
			关联：边/弧与顶点间的关系
				存在边(v,w)	边关联于v和w
				存在弧<v,w>	弧关联于v和w

			顶点的度：与顶点相关联的边的数目，记作TD(v)
				无向图：顶点度 = 关联边数
				有向图：顶点度 = 顶点入度 + 顶点出度
					顶点入度：以顶点v为终点的有向边的条数
					顶点出度：以顶点v为始点的有向边的条数				补充：树根结点入度为0，其余顶点入度为1
				
			边上权值:表示该边的长度

			路径：若干条接续的边构成的顶点序列
			路径长度：路径上边或弧的数目/权值之和
			回路/环：顶点与终点相同的路径						v - w - v
			简单路径/简单回路/简单环：路径起点和终点可以相同外，其余顶点均不相同的路径		v - x - v

		图相关概念：
			有向图：每条边都是无方向的		
			无向图：每条边都是有方向的		

			完全图：任意两点都有一条边相连(无向完全图 + 有向完全图)
				无向完全图：n个顶点，有(Cn2) = n(n -1)/2条边
				有向完全图：n个顶点，有(2Cn2) = n(n - 1)条边

			稀疏图：有很少边或弧的图(边数 < nlogn)
			稠密图：有较多边或弧的图
			子图：图G = (V,E)和X = (M,N),若M ⊆ V(顶点子集)且N ⊆ E(边子集)，称X是G的子图

			网：边/弧带权的图
				有向网：带权的有向图
				无向网：带权的无向图

			连通图：在无向图G = (V,E)中,对任意一对顶点v和u，都存在v到u的路径

				V0———	V1			V0	V1
				|	|			|	|
				|	|			|	|
				V2——— V3			V2	V3	
				  连通图				 非连通图
					
				连通分量：无向非连通图的极大连通子图
				极大连通子图：子图中顶点数已是最大值，添加任意一个顶点，极大子图不再连通
				极小连通子图：子图是G的连通子图，子图中删除任何一条边，子图不再连通
					
			强连通图：在有向图G = (V,E)中，对任意一对顶点v和u，都存在v到u的路径，也存在一条u到v的路径

				V0---->	V1			V0---->	V1
				| ↖	|			| ↖
				↓      	↖			↓       ↖	
				V2---->	V3			V2---->	V3
				 强连通图				 非强连通图

				强连通分量：有向非连通图的极大强连通子图
				极大强连通子图：子图中顶点数已是最大值，添加任意一个顶点，极大子图不再强连通
				极小强连通子图：子图是G的强连通子图，子图中删除任何一条边，子图不再连图

			生成树：包含无向图G所有顶点的极小连通子图
			生成森林：对非连通图，各个连通分量的生成树的集合


	图的存储结构：
		逻辑结构：多对多		
		物理结构：
			顺序存储结构(邻接矩阵)：
				邻接矩阵(两个数组表示图)：
					一维数组：存储图中顶点(数据元素)的信息	
					二维数组：存储图中顶点之间的关系

				一维数组：	存储顶点(数据元素)信息
					Vexs[n]:	
						i		0	1	2	3	...	n-1
						Vexs[i]		V1	V2	V3	V4	...	Vn

				二维数组：	存储顶点间关系
					G.arcs[n][n]:		n为顶点个数，二维数组大小n × n		
	
								1	(v,w)/<v,w> 属于 E边集
						G.arcs[n][n] = 
								0	(v,w)/<v,w> 不属于 E边集
							
					无向图邻接矩阵：				邻接矩阵:	   v1 v2 v3 v4 v5
						V1  —	V2				v1 0  1	 0  1  0	|0  1  0  1  0|
						       / 				v2 1  0  1  0  1	|1  0  1  0  1|
						|   V3	 |				v3 0  1  0  1  1	|0  1  0  1  1|
						  /    \				v4 1  0  1  0  0	|1  0  1  0  0|
						V4	V5				v5 0  1  1  0  0	|0  1  1  0  0|
											
						无向图邻接矩阵特点：
							对角线为0，对角线上的边为自环
							对称，v和w是邻接关系，w和v也是邻接关系
							顶点i的度 = 第i行中1的个数
							完全图的邻接矩阵中，对角元素为0，其余元素为1

					有向图邻接矩阵：				邻接矩阵
						V1  →	V2			  	   v1 v2 v3 v4	
											v1 0  1  1  0		|0  1  1  0|
						↓    ↖					v2 0  0  0  0		|0  0  0  0|	
											v3 0  0  0  1		|0  0  0  1|
						V3  →	V4				v4 1  0  0  0		|1  0  0  0|

						有向图邻接矩阵特点：						行：出度顶点
							有向图的邻接矩阵不可能对称					列：入度顶点
							顶点出度 = 第i行1的个数
							顶点入读 = 第i列1的个数
							顶点度 = 顶点入读 + 顶点出度
				
					网(带权图)：		
								权值	(v,w)/<v,w> 属于 E边集
						G.arcs[i][j] = 
								∞	没有该边/弧		

						有向网邻接矩阵：
							   v1  v2  v3  v4  v5  v6		网的邻接矩阵与有向图一致
							v1|∞   5   ∞  7   ∞  ∞|		将1赋值为权值，0赋值为∞
							v2|∞   ∞   4  ∞   ∞  ∞|	
							v3|8   ∞   ∞  ∞   ∞  ∞|
							v4|∞   ∞   5  ∞   ∞  ∞|
							v5|∞   ∞   ∞  5   ∞  ∞|
							v6|2   ∞   ∞  ∞   1  ∞|

				邻接矩阵优缺点：
					优点：	方便查找任意顶点的所有邻接点
						方便检查任意一对顶点间是否存在边
						方便计算任一顶点的"度"
				
					缺点：	不便于增加删除顶点
						浪费空间，存稠密图较好，稠密图使用邻接矩阵深度遍历
						浪费时间(统计稀疏图中一共有多少边)，时间复杂度O(n^2)
										     
			链式存储结构(邻接表)：
				邻接表(两张表表示图)：
					顶点数组表：按编号顺序存储数据元素				数据元素：边表表头结点(data|firstarc)
						结点示意图：data|firstarc
							data：结点数据域，用于保存结点的数据值
							firstarc：结点指针域，指向结点第一条边的边结点地址

					边表(边链表)：存储与该结点相连的所有边，边链表中的结点称为边结点
						边结点示意图：adjvex|nextarc|info
							adjvex：	边所指的顶点在图中的位置(顶点在顶点数组表中的下标)
							nextarc：指向下一条边/弧(出度边)
							info：存储权值信息

					邻接表示例：
						无向图G及其邻接表：		邻接表：
							V1  —	V2			0 v1|v4地址 -> v4结点|v2地址 -> v2结点|^		
							       / 			1 v2|v5地址 -> v5结点|v3地址 -> v3结点|v1地址 -> v1结点|^
							|   V3	 |			2 v3|v5地址 -> v5结点|v4地址 -> v4结点|v2地址 -> v2结点|^
							  /    \			3 v4|v3地址 -> v3结点|v1地址 -> v1结点|^
							V4	V5			4 v5|v3地址 -> v3结点|v2地址 -> v2结点|^

							特点：
								若无向图有n个顶点，e条边，邻接表需n个头结点 + 2e个表结点
						     		适宜存储稀疏图，且邻接表不唯一(边结点顺序可调换)，稀疏图使用邻接表深度遍历
								顶点的度 = 边表中结点数

						有向图及其邻接表：			正邻接表：
							V1  →	V2			0 v1|v2地址 -> v2结点|v3地址 -> v3结点|^		
											1 v2|^
							↓   ↖				2 v3|v4地址 -> v4结点|^		
											3 v4|v1地址 -> v1结点|^
							V3  →	V4			
										逆邻接表：
											0 v1|v4地址 -> v4结点|^
											1 v2|v1地址 -> v1结点|^
											2 v3|v1地址 -> v1结点|^
											3 v4|v3地址 -> v3结点|^

							特点：	
								若有向图有n个顶点，e条边，邻接表需n个头结点 + e个表结点
								正邻接表：i顶点出度 = 边表中第i个单链表结点数	
								逆邻接表：i顶点入度 = 边表中第i个单链表结点数
						
						补充：邻接表时间复杂度O(n + e)
						     邻接表空间复杂度O(n)

				十字链表：	有向图的链式存储方法(十字链表  ≈ 正邻接表 + 逆邻接表)
					十字链表结点：
						顶点结点示意图：data|firstin|firstout
							data:存储顶点的数据值
							firstin：指向该顶点为弧头的第一个弧结点(入度)		弧头 <==> 入度			(弧尾)------>(弧头)
							firstout：指向该顶点为弧尾的第一个弧结点(出度)		弧尾 <==> 出度
						
						边结点示意图：tailvex|headvex|hlink|tlink|info
							tailvex：以顶点结点为弧尾结点，弧尾在顶点表中的下标
							headvex：以顶点结点为弧头结点，弧头在顶点表中的下标
							hlink：指向弧头相同的下一条弧
							tlink：指向弧尾相同的下一条弧
							info：存储权值信息

					十字链表示例：
						有向图及其十字链表：			十字链表：
							V1  →	V2				    	顶点结点		边结点		边结点			
											弧头结点：0 	v1|入度|^   →	2|0|v3地址|^  →	3|0|^|^		
							↓   ↖	↑			弧尾结点：0 	v1|^|出度     →	0|1|^|v2地址  →	0|2|^|^
																		
							V3  →	V4			弧头结点：1 	v2|入度|^   →	0|1|v4地址|^  →	3|1|^|^
											弧尾结点：1	v2|^|^
													
											弧头结点：2 	v3|入度|    →	0|2|^|^
											弧尾结点：2	v3|^|出度     →	2|3|^|^
												
											弧头结点：3 	v4|入度|^    →	2|3|^|^
											弧尾结点：3 	v4|^|出度    →  	3|1|^|v1地址  →	3|0|^|^
						
				邻接多重表：	无向图的链式存储方法
					邻接多重表结点：
						顶点结点示意图：data|firstedge
							data：存储和该点相关的信息
							firstedge：指向第一条依附于该顶点的边
						
						边结点示意图：mark|ivex|ilink|jvex|jlink|info
							mark:标志域，标记改变是否被搜索过
							ivex/jvex：与边依附的两个顶点在顶点表中的下标
							ilink/jlink：指针域，分别指向依附于顶点ivex和jvex的下一条边
							info：存储权值信息

					邻接多重表示例：
						无限图及其多邻接多重表：			邻接多重表：
							V1  —   	V2				编号	顶点结点		边结点				边结点		
							      /					0	V1|第一条边地址 →	|0|V1V4地址|1|V2V3地址|权值    →	|0|^|3|^|权值
							|   V3	|								         ↓
							  /   \					1	V2|第一条边地址 →	|2|V3V4地址|1|V2V5地址|权值  →	|2|V3V5地址|3|V2V4地址|权值
							V4  	V5						      ↑	       ↳_________↓_________ ↑
												2	V3|第一条边地址  ↑			 ↓	    ↑	
																	 ↓	    ↑
												3	V4|第一条边地址 →→→→→→→→→→→   ↓→→→→→   ↑
																	 ↓
												4	V5|第一条边地址 →	|4|V2V5地址|1|^|权值	  


			邻接矩阵与邻接表之间的关系：
				邻接表中每个边表对应邻接矩阵中的一行	===>	邻接表边表结点数 = 邻接矩阵每行非零元素数
				邻接矩阵：				邻接表：
					对于无向图，邻接矩阵唯一			对于无向图，邻接表不唯一
					空间复杂度：O(n^2)			空间复杂度:O(n + e)
					邻接矩阵多用于稠密图			邻接表多用于稀疏图
			

	图的遍历(找每个顶点的邻接点)：
		概念：
			图的遍历：从给定的连通图的某一顶点出发，沿着图中各边访问图中所有顶点，每个顶点仅被访问一次
			回路：回路上的任一顶点在被访问之后，都有可能沿着回路再次被访问

		避免回路：辅助数组visited[n],标记每个被访问过的顶点		
			数组visited[n]		初始状态		visited[i] = 0
						顶点i被访问	visited[i] = 1		<==>	地图地标已旅游，在地图上打勾
		
		遍历方式：
			深度优先搜索(DFS)：
				从图中某个顶点出发，作为当前顶点。访问此顶点，设置顶点的访问标志。
				从v的未被访问的邻接点中找出一个作为下一步探查的顶点。若当前顶点所有邻接点都被访问过，回退前一步顶点作为探查顶点。	重复操作

				A  —	B			A  →	B
				  \	  \				  ↘
				|   C - D   E			    C ⇄ D   E
				
				|   F	| /			    F	⇅  ↙
				  /   \                           ↙  ↖
				G	H			G	H

				  无向图G			   DFS树

				DFS算法实现：	
					  1 2 3 4 5 6		
					1|0 1 1 1 0 0|			1-------↴
					2|1 0 0 0 1 0|		      /   	4
					3|1 0 0 0 1 0|	       （起点)2	  \	|
					4|1 0 0 0 0 1|			   3	|			DFS结果：2 → 1 → 3 → 5 → 4→ 6
					5|0 1 1 0 0 0|		      \	  /	6				
					6|0 0 0 1 0 0|			5
					 无向图邻接矩阵		       无向连通图G				

					设置辅助数组visited[n]:
					编号：	1	2	3	4	5	6	
				 		0	1	0	0	0	0		2已被访问
						1	1	0	0	0	0		1已被访问，访问1号邻接点4号
						1	1	1	0	0	0		3已被访问，3号邻接点都已被访问回退至1	↑
						1	1	1	0	1	0		5已被访问，5号邻接点都已被访问回退至3	↑
						1	1	1	1	1	0		4已被访问
						1	1	1	1	1	1		6已被访问
													
					邻接矩阵表示图深度优先搜索遍历：			
						void DFS(AMGraph G,int v){					参数邻接矩阵G，起始顶点v
							cout << v;
							visited[v] = true;					访问起始结点，辅助数组设置已访问
							for(w = 0;w < G.vexnum;w++){				遍历邻接矩阵v所在行
								if(G.arcs[v][w] != 0 && (!visited[w])){		
									DFS(G，w)；				递归重复访问
								}
							}			
						}
			
				非连通图深度优先搜索遍历：
					DFS先遍历最大连通子图所有顶点，在其他连通分量中，从任一顶点进行DFS遍历


			广度优先搜索(BFS):
				从图中某个顶点出发，作为当前顶点。访问此顶点，设置顶点的访问标志。				
				v的所有未被访问的邻接点依次作为下一步探查的顶点。从这些邻接点出发依次访问它们的邻接点(先被访问的顶点邻接点 先于 后被访问的顶点邻接点)。   重复操作
			
				A  —	B			A  →	B
				  \	  \			  ↘	  ↘
				|   C - D   E			↓    C→ D   E
				
				|   F	| /			↓    F	   ↙
				  /   \                           ↗  
				G	H			G	H

				  无向图G			   BFS树
				
				BFS算法实现：
					0 V1|1地址 → 1|2地址 → 2|^				V1
					1 V2|0地址 → 0|3地址 → 3|4地址 → 4|^		     /	   \
					2 V3|0地址 → 0|5地址 → 5|6地址 → 6|^		  V2	      V3	
					3 V4|1地址 → 1|7地址 → 7|^			/   \	    /   \	BFS结果：V1 → V2 → V3 → V4 → V5 → V6 → V7 → V8
					4 V5|1地址 → 1|7地址 → 7|^		      V4     V5   V6	 V7
					5 V6|2地址 → 2|6地址 → 6|^			      \
					6 V7|2地址 → 2|5地址 → 5|^			       V8
					7 V8|3地址 → 3|4地址 → 4|^
						无向图邻接表				    无向连通图G

					设置辅助数组visited[n]:
					编号:	1	2	3	4	5	6	7	8

					内容:	1	0	0	0	0	0	0	0		1已被访问
						1	1	0	0	0	0	0	0		2已被访问，V2/V3是V1邻接点	
						1	1	1	0	0	0	0	0		3已被访问，V2/V3是V1邻接点
						1	1	1	1	0	0	0	0		4已被访问，V4/V5是V2邻接点
						1	1	1	1	1	0	0	0		5已被访问，V4/V5是V2邻接点
						1	1	1	1	1	1	0	0		6已被访问，V6/V7是V3邻接点
						1	1	1	1	1	1	1	0		7已被访问，V6/V7是V3邻接点
						1	1	1	1	1	1	1	1		8已被访问，V8是V5邻接点

					邻接表表示图广度优先搜索遍历：
						void BFS(Graph G，int v){						参数邻接表G，起始顶点v		
							cout << v;						
							visited[v] = true;						访问起始顶点，辅助数组设置已访问
							InitQueue(Q);							辅助队列Q初始化置空
							EnQueue(Q,v);							v进队
							while(!QueueEmpty(Q)){
								DeQueue(Q,u);						队头元素出队并置为u
								for(w = FirstAdjVex(G,u);w >= 0;w = NextAdjVex(G,u,w))
								if(!visited[w]){
									cout << w;
									visited[w] = true;
									EnQueue(Q,w);					w进队
								}
							}
						}
					
				非连通图广度优先搜索遍历：
					BFS先遍历最大连通子图所有顶点，在其他连通分量中，从任一顶点进行BFS遍历

	图的应用：
		最小生成树：
			基本概念：
				生成树：所有顶点均由边连接在一起，但不存在回路的图
					V1  --	V2	V1	V2	V1  --	V2
					       /	       /	       /
					|   V3	|	|   V3		    V3	|
					  /    \	  /    \	  /
					V4  	V5  	V4	V5	V4	V5
					  连通图G	  G生成树	    G生成树

					特点：	连通图的每一棵生成树，都是原图的极小连通子图(生成树中删除任何一条边子图不连通,生成树中再加一条边必然形成回路)
					     	生成树不同，每棵树的权值也可能不同
						生成树的顶点个数与图的顶点个数相同
						n个顶点的连通图的生成树有(n - 1)条边			补充：含有n个顶点(n - 1)条边的图不一定是生成树
						生成树中任意两个顶点间的路径是唯一的				V1  --	V2		V1	V2
													       /		       /
				代价：生成树上任一条边的权值							|   V3	 |		|   v3	|
				生成树的代价：树上各边代价之和						  /    \		       \	
				最小代价生成树/最小生成树：G的所有生成树中，代价最小的生成树			V4  	V5		V4	V5

				深度优先生成树：					广度优先生成树：
						V1						V1

					V2		V3				V2		V3

				    V4      V5	    V6      V7			    V4      V5	    V6      V7
					
					      V8   					      V8
					
				顺序：	V1-V2-V4-V5-V8-V3-V6-V7			顺序:	V1-V2-V3-V4-V5-V6-V7-V8

			应用：
				1.n个城市铺(n - 1)条线路/n个城市建立(n - 1)个通信网			解决算法：最小生成树(城市：结点/线路：边)
				2.每条线路都有对应成本，n个城市怎么选择(n - 1)条线路，总费用最少		解决算法：最小代价生成树(城市：结点/线路：边/费用：权值)
		
			构造最小生成树算法/贪心算法(利用MST性质)：			
				MST性质：设N = （V，E）是一个连通网，U是顶点集V的一个非空子集。若边(u,v)∈U，v∈V-U，必存在一棵包含边(u,v)的最小生成树

						V1
					     /	 |   \			顶点集	V = {V1，V2，V3，V4，V5，V6}
					V2  —	V3   —	V4		边集	E = {(V1,V2),(V1,V3),(V1,V4),(V2,V3),(V2,V5),(V3,V4),(V3,V5),(V3,V6),(V4,V6),(V5,V6)}
					|    /	     \	|		在生成树上的顶点集：	U = {V1}
					V5	—	V6		不再生成树上的顶点集：	V - U = {V2，V3，V4，V5，V6}
									权值最小的边：(u,v) = 连通U中顶点和(V-U)中顶点，选取权值最小的边

				Kruskal算法思想(选择边)：
					设N = (V,E)是连通网，最小生成树初始状态只有n个顶点无边的非连通图TE = (V,{})		V：顶点集		{}：边集
					在E中选取代价最小的边
					若该边依附的顶点落在T中不同连通分量上(不能形成环)，将边加入到T中；否则，选取下一条代价最小的边
					重复操作，直至所有顶点都在同一连通分量上

					一：(V1，V3)	权值：1
					二：(V4，V6)	权值：2
					三：(V2，V5)	权值：3
					四：(V3，V6)	权值：4
					五：(V1，V4)	权值：5		形成环，舍弃			补充：最小生成树不唯一
					      (V3，V4)	权值：5		形成环，舍弃	
					      (V2，V3)	权值：5		
					六：(V1，V2)	权值：6		最小生成树构造完成
					
					时间复杂度：O(eloge)
					适应范围：稀疏图
					
				Prim算法思想(选择点)：
					设N = (V,E)是连通网，TE是N上最小生成树(n个顶点/n-1条边)边的集合
					初始另U = {u0}(u0 ∈ V)，TE = {}					U：顶点在生成树上的顶点集
					在所有u ∈ U，v ∈ V-U 的边(u,v) ∈ E中找一条代价最小的边(u0,v0)
					最后将(u0,v0)并入集合TE，同时v0入U
					重复操作，直至U = V，TE为N的最小生成树	

					时间复杂度：O(n^2)	
					适应范围：稠密图
		
		最短路径：
			基本概念：
				带权图路径长度：带权图从一个顶点到图中其余任一顶点的一条路径的权值之和
				最短路径长度/最短路径：在有向网中A点(源点)到达B点(终点)的多条路径中，各边权值之和最小的路径

				补充：最短路径与最小生成树不同，路径上不一定包含n个顶点，也不一定包含(n - 1)条边
			
			应用：	
				1.交通网络问题(有向网)，求源点到其他各点最短路径				解决算法：单源最短路径(Dijkstra算法)
				2.交通网络问题(有向网)，求图中每队对顶点之间的最短路径			解决算法：所有顶点间的最短路径(Floyd算法)
				
			算法：
				Dijistra算法-单源最短路径：		给定带权有向图G和源点v，求v到G中其余各点最短路径
					算法思想(按路径长度递增次序产生最短路径)：
						N = (V,E)	V是顶点集
						1.V分成两组：
							S：已求出最短路径的顶点集合(初始时：S = {源点v0})
						 	T = V - S：尚未确定最短路径的顶点集合
						2.从T中选取一个距离值最小的顶点vj加入S
						3.对T中顶点距离值进行修改，若加入vj作中间顶点，从v0到各终点的距离值比不加vj路径要短，修改此距离值

						补充：
							从源点v0到S中各顶点的最短路径长度都 <= 从v0到T中任一顶点的最短路径长度

							每个顶点对应一个距离值：
								S顶点：从源点v0到此顶点的最短路径长度
								T顶点：从源点v0到此顶点，路径只包括S中顶点的最短路径长度

						设置辅助数组：
							D[]：存放源点v0到其他顶点的最短路径长度(最短路径存在？最短路径长度:♾️)
								
						数组D[]:		终点		从源点v0经过各点到各终点最短路径及长度
				V0					i = 1	i = 2	i = 3	i = 4	i = 5	i = 6
			    ↙	    ↘				v1	13	13	--	--	--	--
			V2		V1			v2	8	--	--	--	--	--	
		       ↙	      ↙	  ↘			v3	♾️	13	13	--	--	--
		     V3		     V5 → V6			v4	30	30	30	19	--	--	
		   ↙		     ↑				v5	♾️	♾️	22	22	21	21
		 V4------------------|				v6	32	32	20	20	20	--
								vj	v2	v1/v3	v3	v4	v6	v5
								距离	8	13	13	19	20	21
							
				Floyd算法-所有顶点间最短路径：		时间复杂度：O(n^3)
					算法思想：
						逐个顶点试探从vi到vj的所有可能存在路径中选出一条长度最短的路径

						1.初始时设置n阶矩阵(n:顶点个数)，另对角线元素为0，若存在弧<vi,vj>,则对应元素为权值，否则为♾️

							设置n阶矩阵：
								初始：	  A B C		路径：
									A|0  4 11|		q	AB	AC
							       		B|6  0  2|		BA		BC
				    			       		C|3 ♾️  0|		CA
							
						2.逐步在原直接路径中增加中间顶点。若加入中间顶点后，从vi到vj路径变短，修改，否则维持原值
							加入A顶点：			路径：
								|0 4 11|				AB	AC
								|6 0 2 |			BA		BC
								|3 7 0 | 			CA 	CAB
						
							加入B顶点：			路径：
								|0 4 6|					AB	ABC
								|6 0 2|				BA		BC				
								|3 7 0|				CA	CAB
			
							加入C顶点：			路径：
								|0 4 6|					AB	ABC
								|5 0 2|				BCA		BC
								|3 7 0|				CA	CAB
								
					补充：用Dijistra算法解决所有顶点间最短路径问题，时间复杂度：O(n^3)

		补充：
			有向无环图：无环的有向图，简称DAG图
			
				 ੦			 ੦			 ੦
			      ↙     ↘		      ↙     ↘		      ↙     ↘
			    ੦   	    ੦		    ੦   	    ੦		    ੦   	    ੦
			  ↙   ↘			  ↙   ↘   ↙		  ↙   ↘   ↙
			 ੦           ੦		 ੦             ੦		 ੦   →   ੦
			     有向树		    DAG图		      有向图
			
		AOV/AOE网基本术语：
			AOV网：图中顶点表示活动，有向边(弧)表示活动之间的制约关系，顶点表示活动的有向图称为AOV网	
				活动：所有的工程或流程可以分成若干小工程或阶段，小的工程或阶段就是活动

				特点：
					从i到j是一条有向路径	→	i是j前驱；j是i后继			C1 → C4 → C5	C1是C5前驱/C5是C1后继
					从i到j是一条有向边		→	i是j直接前驱；j是i直接后继		C1 → C5		C1是C5直接前驱/C5是 C1直接后继
					
				注意：	AOV网中不允许有回路
						AOV网中有回路	→	某项活动以自己为为先决条件

			AOE网(表示工程的进度计划)：有向边(弧)表示活动，顶点表示事件，弧的权值表示活动持续时间，边表示活动的有向图称为AOE网
				事件(顶点)：在它之前的活动已经完成，在它之后的活动可以开始		活动：v1 → v2	(权值：A = 30)
					
				源点：网中入度为0的点
				汇点：网中出度为0的点

		拓扑排序(有向无环图应用)：			解决算法：AOV网
			基本概念：在AOV网中没有回路的前提下，将全部活动排列成一线性序列。
				若AOV网这种有弧<i,j>存在，在这序列中，i一定排在j前面。
				具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序算法为拓扑排序

			构造有向图拓扑排序算法：
				算法思想：
					1.在有向图中选一没有前驱的顶点输出
					2.从图中删除该顶点和以该顶点为弧尾的弧(顶点 + 弧)
					3.重复上述两步，直至全部顶点均已输出或当前图中不存在无前驱的顶点
						
				↱---→	C4		
				|   	    ↘		拓扑排序：C1 C2 C3 C4 C5 C7 C9 C10 C11 C6 C12 C8
				|	C2	C5	 	C9 C10 C11 C6 C1 C12 C4 C2 C3 C5 C7 C8
				|   ↗	    ↗			
				C1  →	C3  →	C7	补充：一个AOV网的拓扑序列不是唯一的
				    ↘	    ↘
					C12	C8	
				    ↗		↑	
				C9  →	C10	↑	
				    ↘		↑	
					C11 →	C6	

			拓扑排序应用(检测AOV网中是否存在环)：对有向图的拓扑有序序列，若网中所有顶点都在拓扑有序序列中，则AOV网中必定不存在环
									
		关键路径(有向无环图应用)：			解决算法：AOE网
			关键路径：整个工程从源点到汇点路径长度最长的路径		路径长度：路径上各活动持续时间之和
			关键活动：关键路径上的所有活动	
			
			构造关键路径算法思路：
			1	定义计算关键路径的量：
				顶点：	
					ve(vj):事件vj最早发生时间		ve(V1) = 0/ve(V2) = 6
					vl(vj):事件vj最迟发生时间
				
				边：	
					e(i):活动ai的最早开始时间		e(V3 → V5) = 4		V1 → V3活动结束，V3 → V5活动开始执行
					l(i):活动ai的最迟开始时间

					l(i) - e(i):表示完成活动ai的时间余量	补充：l(i) - e(i) == 0是关键活动
				
			2	找l(i) == e(i)关键活动：
					设活动ai用弧<j,k>表示，持续时间为Wjk			活动ai：j   →   k
					e(i) = ve(j)			活动ai最早开始时间	= 事件j最早开始时间
					l(i) = vl(k) - Wjk		活动ai最迟开始时间 = 事件k最迟开始时间 - 活动ai持续时间

			3	求事件最早开始时间ve(j)和事件最迟开始事件vl(j):
					从ve(1) = 0开始往后递推：
						事件最早开始时间：ve(j) = Max{ve(i) + Wij}		关键路径	=> 路径权值最大 => ve(i) + Wij(路径长度最大)取最大值

					从vl(n) = ve(n)开始往前递推：
						事件最迟开始时间：vl(i) = Min{vl(j) - Wij}		关键路径 => 路径权值最大 =>	 vl(j) - Wij(路径长度最大)取最小值

			构造关键路径算法：
			设工程有11项活动，9个事件	

				 V2		V7		V1：表示整个工程开始(源点：入度为0的顶点)
				    ↘(1)   ↗(9)    ↘(2)		V9：表示整个工程结束(汇点：出度为0的顶点)
			    ↗(6)	V5		V9
				    ↗(1)   ↘(7)    ↗(4)		(n):表示权值/长度
			V1  →(4)V3		V8			
												
			    ↘(5) 	    ↗(4)			

				 V4  →(2)V6j
			
				1.求ve/vl				2.求e(i)/l(i)/l(i) - e(i)
					顶点	ve	vl			活动		e	l	l - e		关键活动	
					v1	0	0			a1(v1 - v2)	0	0	0		✔	
					v2	6	6			a2(v1 - v2)	0	2	2
					v3	4	6			a3(v1 - v2)	0	3	3
					v4	5	8			a4(v2 - v5)	6	6	0		✔
					v5	7	7			a5(v3 - v5)	4	6	2
					v6	7	10			a6(v4 - v6)	5	8	3
					v7	16	16			a7(v5 - v7)	7	7	0		✔
					v8	14	14			a8(v5 - v8)	7	7	0		✔
					v9	18	18			a9(v6 - v8)	7	10	3
										a10(v7 - v9)	16	16	0		✔
										a11(v8 - v9)	14	14	0		✔

										关键路径：v1-v2-v5-v7-v9/v1-v2-v5-v8-v9
							
										补充：	e(i) = ve(j)			活动ai最早开始时间	= 事件j最早开始时间
											l(i) = vl(k) - Wjk		活动ai最迟开始时间 = 事件k最迟开始时间 - 活动ai持续时间
										


基本数据处理技术：
	查找：		
		表结构：
						学生基本信息表		     出生日期
			学号		名	性别	名族	籍贯	年	月	日	年级	院系	学生类别
			112060826	赵雪清	女	汉	江苏	1988	8	8	2012	计算机	硕士
			110060943	田春峰	男	汉	河南	1989	1	20	2010	计算机	硕士
			212060032	陈亮	男	汉	湖南	1986	11	30	2012	自动化	博士
			212060032	刘明	男	汉	河北	1990	11	12	2013	理学院	硕士
			
		查找相关概念和术语：
			查找表：同一类型数据元素构成的集合
			数据项：构成数据元素不可分割的最小单位				组合项：由若干项组合构成的数据项(出生日期：年-月-日)
			数据元素：由若干项，组合项构成的数据单位
			
			查找：根据给定的值，在查找表中确定一其关键字等于给定值的数据元素
				查找成功：查找表中存在与给定值匹配的记录		返回结果：查找到的记录/查找记录在表中的位置
				查找不成功：查找表中不存在与给定值匹配的记录		返回结果：空记录/空指针
				
			关键字：标识一个数据元素的某个数据项的值
				主关键字：可唯一标识一个记录的关键字
				次关键字：可识别若干记录的关键字
			
			静态查找表：仅对查找表进行查询操作，查找的结果不改变表结构
			动态查找表：对查找表进行查找、插入、删除操作的表，查找的结果改变表结构

			平均查找长度ASL(顺序查找执行次数)：记录的关键字个数与给定值进行比较次数的期望值(期望值：随机变量可能取值的加权平均值)
									 n
					ASL = p1c1 + p2c2 + ... + pici = Σpici
									i=1
					p:查找第i个记录的概率		p = 1/n
					c:找到第i个记录所需的比较次数		

				顺序查找ASL：ASL = (1/n) * [n(n + 1)/2]	
				每个记录的查找概率：p = 1/n	
				所有记录被查找的次数和：1 + 2 + 3 + ...... + n = [n(n + 1)/2]
			
			查找结构：为提高查找效率，专门面向查找操作的数据结构(索引/线性表/树表/哈希表)
					
		线性表的查找：
			顺序表及数据元素类型定义：
				顺序表定义：
					typedef struct{
						ElemType *R;
						int length;
					}L；

				数据元素类型定义：
					typedef struct{
						keyType e；
						InfoType otherinfo；
					}ElemType；

			查找：
			1	顺序查找(顺序存储，数据无序)：
					算法思想：从表的一端开始，依次将记录关键字与给定值比较，记录的关键字与给定值相等，查找成功；反之，查找失败

					算法实现：
						int LocateElem(SeqList L,ElemType e){			
							for(int i = L.length(); i >= 1;--i){			从顺序表末尾往前找
								if(L.R[i].key == e){
									return i + 1;	
								}	
								return 0;
							}
						}
	
					改进：将待查关键字key存入表头，从后往前逐个比较，免去查找过程中每一步检测是否查找完毕
						int LocateElem(SeqList L,ElemType e){
							L.R[0].key = e;
							for(i = L.length;L.R[i].key != e;--i);			当前元素key != e,巡检继续；当前元素key = e，循环停止
							return i;
						}
					
					算法分析：
						时间复杂度：
							查找成功：(n - i + 1)次		查找第i个元素
							查找失败：(n + 1)次
							平均查找长度：ASL = (1/n) * [n + (n - 1) + ... + 1] = (1/n) * [n(n + 1)/2] = (n + 1)/2
							
						空间复杂度：辅助空间O(n)

					优缺点：	
						优点：算法简单
						缺点：时间效率低(例子：看书找单词)
												
			2	折半查找/二分查找(顺序存储，数据有序)：
					算法思想：					
						在表中取位于中间记录作为比较对象，若中间记录关键字与给定值相等，查找成功		mid = (low + high)/2
						中间记录关键字大于给定值，在中间记录左半区继续查找				R[mid].key > x，high = mid - 1
						中间记录关键字小于给定值，在中间记录右半区继续查找				R[mid].key < x，low = mid + 1
						low > high,查找失败	
					
						1   2   3   4   5   6   7   8   9   10  11						
						5   13  19  21  37  56  64  75  80  88  92				R[mid].key > x，high = mid - 1
						low		    mid			high

						5   13  19  21  37  56  64  75  80  88  92				R[mid].key < x,low = mid + 1
						low     mid     high			
						
						5   13  19  21  37  56  64  75  80  88  92				R[mid].key < x,low = mid + 1
						        mid low high	

						5   13  19  21  37  56  64  75  80  88  92				R[mid].key = x
						            mid high	
							
						补充：low：下届	high：上届 	mid：中点					

					算法实现：
						int BinarySearch(SeqList L,ElemType e){
							low = 1;					设置数组下届
							high = L.length;				设置数组上届
							while(low <= high){		
								mid = (low + high)/2;			设置数组中点
								if(L.R[mid].key == e){			R[mid].key = x
									return mid;
								}else if(e < L.R[mid].key){		R[mid].key > x	
									high = mid - 1;			
								}else{					R[mid].key < x
									low = mid + 1;			
								}
							}	
							return 0;					顺序表中不存在待查元素
						}

					算法分析：
						i	1  2  3  4  5  6  7  8  9  10  11		
						数据	5  13 19 21 37 56 64 75 80 88  92	
						Ci	3  4  2  3  4  1  3  4  2  3  4			Ci:比较次数

						折半查找判定树：		描述折半查找过程	

									6
								   ↙	    ↘
								3		9
							      ↙    ↘ 	      ↙   ↘
							    1	    4	    7	    10
							     ↘	     ↘	     ↘        ↘
							       2       5       8        11
							
						查找成功：比较次数 = 路径上的结点数 = 结点的层数 <= log2n + 1
						查找失败：比较次数 = 路径上内部结点数 <= log2n + 1

						查找成功平均查找长度ASL：
							假设表长n = 2^h - 1,h = log2(n + 1),判定树为深度 = h的满二叉树，且每个记录的查找概率相等：P = 1/n
							ASL = (n + 1)log2(n + 1)/n - 1 ≈ log2(n + 1) - 1(n > 501)
						
					优缺点：	
						优点：效率比顺序查找高
						缺点：只适用于有序表，仅限于顺序存储结构
						
			3	分块查找(索引查找)：	
					算法思想：
						前提：
							将查找表分为若干个块，块内元素可以无序，块间元素有序		
							需要建立索引表对每个子表进行索引				
						
							补充：	
								分块有序：整个查找表无序，将查找表看作几个子表，每个子表中的关键字是有序的
								索引表的索引项 = 子表最大关键字(子表中最大关键字值) + 子表起始地址(子表第一个记录在表中位置)

						思想：	将待查记录与块最大关键字进行比较确定待查记录所在块，再在块内进行顺序查找/折半查找
							
					算法分析：
						将长度为n的表均匀分为b块(子表)，每块有m个记录		==>	b = n/m
						分块查找效率：ASL = La(索引表平均查找长度ASL) + Lb(块内查找平均查找长度ASL)

						顺序查找确定块位置:ASL = (b + 1)/2 + (m + 1)/2 = 1/2(n/m + m) + 1
						折半查找确定块位置:ASL = log2(n/m + 1) + m/2
							
					优缺点：	
						优点：插入和删除比较容易，无需进行大量元素移动
						缺点：增加一个索引表的存储空间并对初始索引表进行排序运算

				查找方法比较：折半查找ASL < 分块查找ASL < 顺序查找ASL

		树表的查找(动态查找和排序)：			动态查找：对于给定值key，若表中存在，成功返回；否则，插入关键字等于key的记录
			二叉排序树/二叉查找树：
				定义：二叉排序树是空树，或是满足以下性质的树：
						若其左子树非空，左子树上所有结点的值均小于根结点的值
						若其右子树非空，右子树上所有结点值均大于等于根结点的值
						其左右子树分别是二叉排序树
				
				二叉排序树示例:				
								55
							    ↙	     ↘	
							31		73
						      ↙   ↘         ↙
						    11      37	    63
						  ↙		   ↙		中序遍历：2 7 11 31 37 55 46 63 73
						 2		 46		二叉排序树中序遍历序列结点值递增
						  ↘	
						   7  

				二叉排序树操作：
					二叉排序树存储结构：
							typedef struct{
								KeyType key；					//关键字域
								InfoType otherinfo；				//其他数据域
							}ElemType；
							
							typedef struct BSNode{
								ElemType data;					//数据域
								struct BSTNode *lchild,*rchild;			//左右孩子指针
							}BSTNode，*BSTree；

					二叉排序树递归查找：
						算法思想：
							若二叉树排序树为空，查找失败，返回空指针
							若二叉排序树非空，将给定key与根结点的关键字进行比较：
								key = 根结点关键字值，查找成功，返回根结点地址
								key < 根结点关键字值，查找左子树
								key > 根结点关键字值，查找右子树
							
						算法实现：
							BSTree SearchBST(BSTree T,KeyType key){
								if((!T) || key == T -> data.key){		//非空且key = 根结点关键字值
									return T；		
								}else if(key < T -> data.key){			//key < 根结点关键字值
									return SearchBST(T -> lchild,key);				
								}else{						//key > 根结点关键字值
									return  SearchBST(T -> rchild,key);
								}
							}

						算法分析：	
							关键字比较次数 = 结点所在层次数	最多比较次数 = 树的深度
														
							含有n个结点的二叉排序树的平均查找长度和树的形态有关
							最优情况：二叉排序树与折半查找判定树相同		ASL = log2(n + 1) - 1	时间复杂度：O(log2n)
								
									45
								    ↙	     ↘
								24		53
							      ↙   ↘		  ↘	
							     12    37	    	    93

							最差情况：单支树形态				ASL = (n + 1)/2		时间复杂度：O(n)
								12
								  ↘
								    24
								      ↘
								        37
									  ↘
									    45
									      ↘
										53
										  ↘
										    93
							
					二叉排序树插入生成：		将无序序列构造二叉排序树变成有序序列
						算法思想：
							若二叉排序树为空，插入结点作为根结点到空树中
							若二叉排序树非空，在左子树、右子树上查找是否已有关键字为key的结点
								插入结点已存在，不能重复插入结点
								插入结点不存在，在该查找路径上的最后一个叶子结点插入左孩子结点/右孩子结点

						补充：	插入的结点均为叶子结点，无需移动其他结点
							不同次序的序列生成不同形态的二叉排序树
							
					二叉排序树的删除：
						算法思想(3种情况)：
						1	删除叶子结点：直接删除该结点
						2	删除结点只有左子树或只有右子树：用其左子树或其右子树替换	  <==>	双亲结点的指针域指向被删除结点的左子树或右子树
						3	删除结点既有左子树，也有右子树：
								用其前驱结点进行替换，再删除该前驱结点，前驱结点是左子树中最大的结点
								用其后继结点进行替换，在删除该后继结点，后继结点是右子树中最大的结点


			平衡二叉树(AVL树)：		平衡二叉树 = 二叉排序树 + 平衡			
				作用：提高二叉排序树的查找效率				

				定义：平衡二叉树是空树，或是满足以下性质的二叉排序树：
						左子树与右子树高度之差绝对值小于等于1(平衡)
						左子树和右子树也是平衡二叉树
				
				平衡二叉树相关概念：		
					结点平衡因子BF = 结点左子树深度 - 结点右子树深度
					平衡二叉树上所有结点平衡因子BF = {-1,0,1}
					失衡结点：平衡因子绝对值大于1的结点
					最小不平衡树：距离插入结点最近且平衡因子绝对值大于1的结点作为根的子树
				
					最小不平衡树示例：
					插入新值前：					插入新值后：					
								25						25			
							    ↙        ↘					    ↙	    ↘		
							20		32				20		32(平衡被破环结点)
						      ↙      ↘	      ↙    ↘			      ↙   ↘	      ↙	  ↘
						    18      22	    28	    35			    18      22	    28	    35
								  ↙     ↘					   ↙  ↘
								 27    29					 27    29				
														      ↙
														     30(新插入结点)	

					最小不平衡树：
							32
						     ↙	   ↘
						   28	    35			选取最近被破坏结点原因：最近平衡被破坏点恢复平衡，上面的结点平衡性也会恢复
						 ↙   ↘
					       27      29
						      ↙
						    30
							
				失衡二叉排序树调整(动态插入)：
					失衡二叉排序树：平衡二叉排序树插入结点时，可能导致失衡
		
							平衡二叉排序树						失衡二叉排序树(53结点失衡)					
							40(BF:0)						40(BF:0)
						    ↙ 	       ↘				·	       ↙ 	↘
						24(BF:-1)	53(BF:-1)		插入60		24(BF:-1)	53(BF:-2)
						   ↘		   ↘					       ↘	    ↘
					     	     28(BF:0)	     70(BF:0)				     28(BF:0)	     70(BF:1)
											插入结点				   ↙
															  60(BF:0)
					
					动态插入：		调整失衡二叉排序树恢复平衡
						调整原则：
							1.降低高度
							2.保持二叉排序树性质

						LL型：				调整：			例子：				调整:
								A			B				5			4
							     ↙			     ↙     ↘			     ↙		     	     ↙	   ↘
							   B			   C	     A			   4		           2	     5
							↙							↙
						      C							      2	

						RR型：				调整：			例子：	  			调整：
						      A					B			4	      			6
						        ↘			     ↙     ↘		     ↙     ↘			     ↙	   ↘
							   B			   A	     C		   2	     6			   4	     8
							     ↘							   ↙   ↘		 ↙   ↘	       ↘	
								C						  5	8		2     5	 	 9	
															   ↘
															    9

						LR型：				调整：			例子：				调整：
							       	A			C			16				7
							     ↙			     ↙    ↘		      ↙				     ↙	   ↘
							   B			   A	    B		   3				   3	    16	
							     ↘						      ↘
								C						7
								
						RL型：				调整：			例子：				调整：
							  A				C			7				9
							     ↘			     ↙	  ↘		     ↙	   ↘			     ↙	  ↘		
								B		   B	    A		   3	    11			   7	    11
							     ↙							   ↙  ↘		 	 ↙  ↘	      ↘
							  C							  9	16		3     8	       16
														↙
														8
							A：失衡结点，最小不平衡树的根结点		
							B：A结点的孩子,C结点的双亲			A -> B -> C路径：从最小失衡树根结点到失衡结点的路径
							C:插入的新结点

				失衡二叉树例题：输入关键字序列(16,3,7,11,9,26,18,14,15),给出一棵AVL树的步骤

					构造：		→	LR型调整：	→	LL型调整：		→	RR型调整：
						16			7			7			       11
					     ↙			     ↙	    ↘		     ↙	    ↘			     ↙	  ↘
					   3			   3	    16		   3	    11			   7	    16
					    ↘				  ↙		 	  ↙   ↘		 	↙    ↘	      ↘
					      7				11	        	 9     16	        3     9	 	26
								      ↙				      	  ↘			      ↙
								     9				    	    26			    18	
																↓	 
											LR型调整：		←	RL型调整：
												11				11
											      ↙	     ↘			      ↙	   ↘
											    7	     18			    7	     18
											  ↙  ↘      ↙  ↘		  ↙   ↘     ↙  ↘
											3     9   15	26		 3     9   16   26
												↙     ↘			       ↙			
											       14    16			      14	
																↘
															  	 15

			红黑树(自平衡二叉树)：			
				定义：红黑树是一种接近平衡的二叉树，没有平衡二叉树平衡因子BF概念，靠满足红黑结点性质维持接近平衡的结构，允许一定不平衡存在

				红黑树性质：
				1	结点是红色或黑色
				2	根是黑色
				3	所有叶子结点都是黑色	
				4	每个红色结点必须有两个黑色子结点	<==>	红色结点的子结点都是黑色		注意：红黑树中叶子结点是空结点NULL
						红色结点的父结点都是黑色
						从根结点到叶子结点的所有路径上不能有2个连续的红色结点
				5	从任一结点到其每个叶子结点的路径上，黑色结点数量相同
					
					补充：	根结点到其叶子结点路径长度最短，路径由红色和黑色结点间隔构成	←	性质：从任一结点到其叶子结点路径上，黑色结点数相同
						根结点到其叶子结点路径长度最长，路径由黑色结点构成		←	性质：根结点到叶子结点的所有路径不能出现两个连续的红色结点
						最长路径长度 <= 2 * 最短路径长度

				红黑树示例：			
									   53(黑)					性质：根结点是黑色
								↙			↘
							34(红)					80(红)			性质：叶子结点是红色或黑色
						    ↙	      ↘			             ↙	    ↘
					 	18(黑)		46(黑)		       74(黑)		88(黑)		性质：根结点到叶子结点不能有两个连续的红色结点
					      ↙	   ↘	     ↙      ↘	     	    ↙	   ↘	      ↙	   ↘      	    `
					   17(红)    33(红) ^	     50(红)	 72(红)	     ^	   ^	      ^			
					  ↙  ↘	    ↙  ↘	   ↙   ↘       ↙  ↘
					 ^    ^	   ^    ^	   ^	^     ^	   ^					性质：所有叶子结点都是黑色
					
				红黑树操作：		红黑树查找/插入/删除时间复杂度O(logn)
					红黑树的查找：
						算法思想：
							若红黑树为空，查找失败，返回空指针
							若红黑树非空，将给定key与当前结点关键字进行比较：
									key = 当前结点关键字值，查找成功，返回该结点关键字值
									key < 当前结点关键字值，查找左子树，将当前结点更新为左子结点
									key > 当前结点关键字值，查找右子树，将当前结点更新为右子结点
								重复上述步骤，直至找到目标结点或当前结点为空

					红黑树旋转：
						
						
					红黑树的插入：
						算法思想：

					红黑树的删除：
						算法思想：
				

				优缺点：
					优点：	红黑树适合用于处理插入、删除、查找等操作
						具有良好平衡性，树高保持较小，查找效率较高

					缺点：	大数据量，层级较深，检索速度慢
						实现比较复杂，需遵守红黑树特性
			

			B-树(B树)：	
				作用：B-树是一平衡多路查找树，作为MySQL数据库索引结构，key表示键data表示键对应条目在硬盘上的逻辑地址，提高访问速度

				定义：一棵m阶的B-树是空树，或是满足以下性质的m叉树：
						树中每个结点至多有m棵子树，至多有(m - 1)个关键字
						若根结点不是叶子结点，至少有2棵子树，至少有1个关键字
						除根结点之外所有非叶子结点至少有[m/2]棵子树，非根结点至少有Math.ceil(m/2)-1个关键字				补充：[m/2] = Math.ceil(m/2)
						结点的关键字都按照从小到大的顺序排列，每个关键字的左子树所有关键字都小于它，右子树的所有关键字都大于它
						所有叶子结点都位于同一层/根结点到每个叶子结点长度相同

				B-树相关概念：
					m阶B-树：度为m的B-树					树的度：树内所有结点度的最大值
					关键字：存储在B树结点中的数据项				结点的度：结点拥有的子树(孩子)的个数
					[m/2]:向上取整，向上舍入到最接近的整数	
					记录 = key(关键字) + data(关键字对应的数据)

				B-树示例：
					4阶B-树(每个结点至多有3个关键字,每个结点至多有4个子树):					性质：每个结点至多有m棵子树，至多有(m - 1)个关键字
									39|^|^						性质：根结点不是叶子结点，至少有2棵子树，至少有1个关键字
								  ↙		     ↘
							12|22|^				53|^|^				性质：除根结点之外的所有非叶子结点至少有2棵子树，非根结点至少有1个关键字
						    ↙	   ↓	 ↘		    ↙		    ↘
				        叶子节点   5|8|9	13|15|^	  25|29|35	41|50|^		  97|^|^		性质：结点关键字都从小到大顺序排列，每个关键字的左子树所有关键字都小于它，右子树所有关键字都大于它
															性质：所有叶子节点都位于同一层
				B-树操作：		查找/插入/删除时间复杂度：O(n)
					B树的查找：	
						算法思想：	
							到达某节点时，先在有序表中查找，若找到，返回相关记录；	
							若未找到目标关键字，而存在两个关键字i、j，使得i < key <j，选择对应的子节点(子树)，在该节点对关键字进行二分查找
							若在查询过程中到达叶子节点仍未找到目标关键字，则查询失败
							
							查找过程：
								在B-树中查找结点			在磁盘上进行
								在结点中查找关键字			在内存上进行

			
					B树的插入：
						算法思想：
							检查该结点是否有足够空间容纳新关键字/判断终端结点关键字数量是否满足：n(关键字数量) <= m - 1(结点最大关键字数)：
								满足，直接在该终端结点上正确位置添加关键字
							***	不满足(该结点已满)，将该节点分裂为两个结点(关键字和相应子树)：
									左部分所含关键字放在旧结点中，右部分所含关键字放在新结点中，中间位置关键字连同新节点存储位置插入到父节点
							若结点关键字个数超过(m -1),父结点继续分裂，直至插入到某个父结点

							补充：	
								非终端结点：B树种除叶结点之外的所有其他结点
								终端结点：叶节点位于B树最底层的结点，没有子树
						
						B-树插入示例：
							初始化：			
											45
										↙		↘
									24				53|90
								     ↙	   ↘		    	    ↙	  ↓	↘	
								3|12	      37		50	61|70	   100

							插入关键字30：
											45
										↙		↘
									24				53|90
								     ↙	   ↘			   ↙	  ↓	↘
								3|12	      30|37		50	61|70	   100

							插入关键字26：
											45
										↙		↘
									24				53|90
								     ↙	   ↘			    ↙	  ↓	↘
								3|12	      26|30|37		50	61|70	   100		注意：26|30|37有3个关键字，3阶B树一个结点最多有2个关键字

							分裂：
											45
										↙		↘				
								      24|30				53|90
								   ↙ 	↓    ↘		   	   ↙	   ↓	↘
								3|12	26	37      	50	61|70	   100		分裂：左部分关键字放在旧结点中，右部分关键字放新结点中，中间关键字插入到父节点					
						

					B树的删除：
						算法思想：
						1	删除最底层结点中关键字
								若被删关键字所在结点中关键字个数大于等于[m/2],直接删除
								若被删关键字所在结点中关键字个数等于[m/2] - 1，进行调整：
									若其左右兄弟结点有"多余"关键字(与该结点相邻的右兄弟结点的关键字数目大于[m/2] - 1)，将左/右兄弟结点最小关键字上移至父节点
									将双亲结点中小于该上移关键字下移至被删关键字所在结点
								若被删关键字与其相邻兄弟结点中关键字数等于[m/2]：
									删除关键字后，将所在结点剩余关键字和指针 + 双亲结点关键字Ai + 兄弟结点关键字合并
						
						2	删除为非底层结点中关键字
								若被删关键字为该结点第i个关键字key[i],在该关键字子树中找到最小关键字，代替key[i]并在其子树中删除代替的最小关键字

						B-树删除示例：
							初始化：
											45
										↙		↘
									24				53|90
								     ↙	    ↘			    ↙	  ↓	↘	
								3|12	      37		50	61|70	   100	

							删除关键字12：		
											45
										↙		↘
									24				53|90
								     ↙	    ↘			    ↙	  ↓	↘	
								  3	      37		50	61|70	   100		被删关键字所在结点中关键字个数大于等于[m/2]，直接删除

							删除关键字50：
											45
										↙		↘
									24				61|90			61上移替换53，53下移替换50
								     ↙	    ↘			    ↙	  ↓	↘	
								  3	      37		53	 70	   100		兄弟结点有多余关键字，较小关键字上移至父节点，父节点小于该关键字下移至被删处

							删除53：
											45
										↙		↘
									24				 90			
								     ↙	    ↘			    ↙	   	↘		
								  3	      37		61|70	 	   100		删除关键字后，将所在结点剩余关键字和指针 + 双亲结点关键字Ai + 兄弟结点关键字合并
										
				B树优缺点：
					优点：	B树始终平衡，所有叶子结点位于同一层
						实际应用B树阶数m非常大(大于100)，即使存储大量数据，B树高度仍然很小
						查找、插入、删除时间复杂度均为O(logn)

					缺点：	B树不适合小规模数据
						B树实现比二叉排序树复杂，占用较多内存空间


			B+树：
				作用：B+树是B树的进一步优化，常用于数据库和文件系统中进行快速数据查询和存储
				
				定义：一棵m阶的B+树至少包含一个根结点，或是满足以下性质的m叉树：
						树中每个结点至多有m棵子树，至多有(m - 1)个关键字
						除根结点之外所有非叶子结点至少有[m/2]棵子树，非根结点至少有Math.ceil(m/2)-1个关键字				
						若根结点不是叶子结点，至少有2棵子树，至少有1个关键字
						结点的关键字都按照从小到大的顺序排列，每个关键字的左子树所有关键字都小于它，右子树的所有关键字都大于它
						所有叶子结点都位于同一层/根结点到每个叶子结点长度相同，B+树叶子结点通过链表相连
						叶子结点中至少有[m/2]个关键字

				B+树示例：
					3阶B+树(每个结点至多有2个关键字,每个结点至多有3个子树):					性质：每个结点至多有m棵子树，至多有(m - 1)个关键字
									60|90|^						性质：根结点不是叶子结点，至少有2棵子树，至少有1个关键字
								  ↙		     ↘
							20|39|60			85|99|^				性质：除根结点之外的所有非叶子结点至少有2棵子树，非根结点至少有1个关键字
						    ↙	   ↓	 ↘		    ↙		    ↘
				       	    10|20|^ → 27|36|39 → 46|51|60  →	65|79|85    →	   92|99|^		性质：结点关键字都从小到大顺序排列，每个关键字的左子树所有关键字都小于它，右子树所有关键字都大于它
															性质：所有叶子节点都位于同一层
				B+树操作：
					B+树的查找：
						算法思想：
							从根结点开始，比较查找关键字k与当前结点的关键字集合
							根据关键字大小，选择对应子结点继续查找，直到到达叶子结点
							叶子结点存储实际数据，在叶子结点进行顺序或二分查找，找到对应数据

						时间复杂度：O(logn)
				
					B+树的插入：
						算法思想：
							根据插入关键字值与结点中关键字值比较，选择合适子树进行查找，直到找到叶子结点
							如果叶子结点关键字数未满，直接插入关键字
							如果叶子结点关键字数已满，将叶子结点分裂为两个结点，左部分所含关键字放在旧结点中，右部分所含关键字放在新结点中，中间位置关键字插入到父节点
							若父节点关键字也已满，父结点继续分裂，直至插入到某个父结点

						时间复杂度：O(logn)
							
					B+树的删除：
						算法思想：
							根据删除关键字与结点中关键字值比较，选择合适子树进行查找，直到找到叶子结点
							若没有找到该关键字，删除操作结束
							找到该关键字，直接删除，检查结点键值数量。
							若叶子结点中关键字数少于[m/2],需要进行调整：
								合并：将该结点与相邻兄弟结点合并
								借键：若相邻的兄弟结点有多余关键字，将左/右兄弟结点最小关键字上移至父结点，将双亲结点中小于该上移关键字下移至被删关键字处
							从删除的结点往上递归，确保每个结点都满足最小关键字

						时间复杂度：O(logn)
				
			B-树和B+树区别：
				B树：	所有结点都存储关键字和数据(指向数据的指针)，消耗更多空间
					B树查询在某非叶子结点找到直接返回数据
					B树适合频繁单点查询，做一般索引
				
				B+树：	非叶子结点只存储关键字不存储实际数据，叶子结点存储所有键值(数据)，有效节省空间
					叶子结点在B+树中通过指针串联成双向链表，方便范围查询
					B+树查询必须经过叶子结点才能找到实际数据


		哈希表的查找：			哈希表 = 散列表
			基本概念：
				散列存储：选取某个函数H，依该函数按关键字计算元素的存储位置p = H(key)		H:哈希函数	p：散列地址
				散列表：按散列存储思想构造的表
				散列方法：
					存储：通过哈希函数计算记录的哈希地址，按哈希地址储存该记录
					查找：根据哈希函数计算记录的哈希地址，将关键字与地址元素关键字进行比较，按哈希地址访问该记录
				冲突：不同的关键字有可能得到相同的哈希地址，H(key1) = H(key2)			y = x^2
				同义词：有相同哈希地址的关键字						y = 1时，x = 1 或 -1

				补充：在散列查找中，冲突是不可避免的，只能尽可能减少
			
			采用散列技术面临问题：
				1.哈希函数的设计：如何设计一个合理的哈希函数
				2.冲突的处理：如何制定解决冲突的方法
			
			哈希函数构造：
				哈希函数设计原则:
					1.计算简单，散列地址空间尽量小
					2.每个关键字所对应哈希地址分布均匀

				构造方法：
					1.直接定址法：定义一个线性函数，取关键字对于该函数的函数值作为就哈希地址，即：H(key) = a * key + b
						例：现有关键字集合{25，15，5，40，45，0，30}，选用散列函数H(key) = key/5进行散列
						
						散列表:
							0	1	2	3	4	5	6	7	8	9
							0	5	/	15	/	25	30	/	40	45
						
						优缺点：
							优点：线性函数值作为散列地址，不会产生冲突
							缺点：关键字跨度大，空间效率低
					
					2.除留余数法：选择常数p，取关键字除以p所得余数作为哈希地址，即：H(key) = key mod p		
						例：现有关键字集合{15，23，27，38，53，61，70}
						
						选取p：	
							1.若哈希表长为m，p <= m且接近m，一般选用质数作为p
							2.不包含小于20质因子的合数

						散列表：	p = 7
							0	1	2	3	4	5	6	
							70	15	23	38	53	61	27
								
					3.平方取中法：取关键字平方后的中间几位作为哈希地址
						例：现有关键字集合{3456，2564，3466，3454}
						
						选取地址位数：由表长决定
							
						求哈希表：
							关键字		关键字平方		所选哈希地址
							3456		11943936		43
							2564		6574096			40	
							3466		12013156		13
							3454		11930116		30

					4.数字分析法：关键字集合中每个关键字均由m位组成，每位有r种不同取值，分析r中符号正在每一位的分布情况，选择其中较为均匀的符号组成哈希地址
						例：现有关键字集合{6537685，6533251，6536543，6542019，6539834，6541234，6545437}

						关键字分析表：
							第一位	第二位	第三位	第四位	第五位	第六位	第七位
							6	5	3	7	6	8	5
							6	5	3	3	2	5	1
							6	5	3	6	5	4	3	
							6	5	4	2	0	1	9
							6	5	3	9	8	3	4
							6	5	4	1	2	3	4	
							6	5	4	5	4	3	7
								
							第一位、第二位均为6、5，第三位取值为3、4，剩余4位取值分布均匀，选取四位中任一两位组成哈希地址
				
			冲突处理：
				处理冲突：关键字按哈希函数计算出的哈希地址发生冲突，需找另外的存储空间存放该关键字值
									
				处理冲突方法：
					1.开放地址法：
						根据关键字所得哈希地址发生冲突，按某种规则寻找下一个空哈希地址，散列表足够大总能找到空散列地址并将数据元素存入
							函数定义：Hi = (Hash(key) + di) mod m	
							H：哈希函数	m：哈希表表长		di：增量序列
					
						常用寻找空哈希地址方法：
							线性探测再散列：
								取增量序列di为1，2，...，m-1线性序列，当哈希地址i发生冲突时，查看哈希地址i+1是否为空，为空将数据放入，依此类推
							
							二次探测再散列：
								取增量序列di为1^2,-1^2,2^2,-2^2,...,q^2二次序列，当哈希地址i发生冲突时，查看哈希地址i+1是否为空，为空将数据放入，依此类推
					
							伪随机函数再散列：
								取增量序列di为伪随机数，当哈希地址i发生冲突时，产生伪随机数d1，查看哈希地址i+d1是否为空，为空将数据放入，依此类推
								
					2.再哈希法：
						使用k个哈希地址，若第一个函数发生冲突，使用第二个函数再生成一个地址，直至产生的地址不冲突
					
					3.链地址法(拉链法)：
						将每个哈希地址作为指针，指向一个链表，m个哈希地址就设m个单链表
						根据关键字得到的哈希地址，将产生冲突的关键字存储到地址i指向的链表中

						例：现有关键字集合{35，51，36，43，12，6，17，40，69，29}，哈希表长为11，Hash(key) = key mod 11
							余数	地址
							0	^
							1	12哈希地址  
							2	35哈希地址  
							3	36哈希地址  →	36|69地址   →	69|^
							4	^
							5	^
							6	51哈希地址  →	51|6地址	   →	6|17地址	  →   17|^
							7	40哈希地址  →	40|29地址   →	29|^
							8	^
							9	^
							10	43哈希地址  →	43|^
							11	^
							12	^
					
					4.建立公共溢出区：
						设哈希函数产生的哈希地址集为[0，m-1]，分配两个表(基本表 + 溢出表)
						基本表：每个存储单元存放一个数据元素
						溢出表：存放关键字的哈希地址在基本表上发生冲突的元素
			
			哈希查找算法：
				算法思想：
					给定待查找关键字key，根据哈希函数计算哈希地址h = H(key)
					若哈希地址h中元素为空，所查元素不存在
					若哈希地址h中元素关键字为key，查找成功
					按处理冲突方法计算下一个哈希地址Hi
						若单元Hi为空，所查元素不存在
						若单元Hi中元素关键字为key，查找成功	

				性能分析：
					ASL决定因素：
						1.哈希函数是否均匀(一般而言，哈希函数是均匀的)
						2.选取冲突处理方法
						3.哈希表装填因子a(a = 哈希表中元素个数/哈希表长度，a是哈希表满程度指标)
					
					不同冲突处理方式ASL：
						线性探测法	ASL = 1/a *ln(1 - a)
						链地址法		ASL = 1 + a/2
						二次探测法	ASL = 1/2 * [1 + 1/(1-a)]


	排序技术：
		排序相关概念及术语：
			排序：一系列数据(有多个数据域)，针对某个数据域，按照递增或递减的顺序排列
			一趟：在排序过程中，将排序的记录序列扫描一遍

			排序稳定性：经过排序后具有相同关键字的元素之间相对次序保持不变
			排序不稳定：经过排序后具有相同关键字的元素之间相对次序发生变化

			内部排序：在排序过程中，将所有记录全部放置在内存中			内部排序：插入排序/交换排序/选择排序/归并排序/基数排序
			外部排序：在排序过程中，需要在内外存之间多次交换数据	
	
			正序：排序序列中记录按关键字排序
			逆序：排序序列中记录排列顺序与排序后排列顺序相反

			串行排序：根据单个关键字进行排序
			并行排序：根据多个关键字进行排序

			比较排序：通过关键字之间的比较、记录的移动实现排序			比较排序：插入排序/交换排序/选择排序/归并排序
			基数排序：不比较元素大小，仅根据元素本省取值确定有序位置

			原地排序：辅助空间用量为O(1)的排序方法/所占辅助存储空间与参加排序数据量大小无关
			非原地排序：辅助空间用量超过O(1)的排序方法/需要额外的辅助存储空间

		插入排序：	
			基本思想：未排序的数据按其关键字大小插入到已完成排序的有序序列中，直到全部记录排序结束
		
			直接插入排序：		排序数据量很小，用顺序查找法查找插入位置
				算法思想：
					第一个元素默认是已排序的
					从第二个元素开始，将其与已排序的元素逐一比较，找到应插入位置
					将当前元素插入到对应位置并移动比它大的元素	
					逐步将后续元素插入到已排序部分，直到所有元素都排好序

				算法演示：
					89	45	54	29	90	34	68
					89	45	54	29	90	34	68			第一次排序
					45	89	54	29	90	34	68			第二次排序
					45	54	89	29	90	34	68			第三次排序
					29	45	54	89	90	34	68			第四次排序
					29	45	54	89	90	34	68			第五次排序
					29	34	45	54	89	90	68			第六次排序
					29	34	45	54	68	89	90			第七次排序

				算法实现：
					void InsertSort(SqList &L){
						int i,j;
						for(int i = 2;i <=L.length;++i){				//从第二个数开始循环，第一个默认已排序
							if(L.r[i].key < L.r[i - 1].key){			//当前数	< 前一个数
								L.r[0] = L.r[i];				//将该记录存入监视哨
								L.r[i] = L.r[i - 1];				//前一个数后移，空出前一个数的位置
								for(j = i - 2;L.r[0].key < L.r[j].key;j--){	//比较当前数与已排序元素大小
									L.r[j + 1] = L.r[j];			//记录后移，空出位置
								}
								L.r[j + 1] = L.r[0];				//将监视哨值插入到正确位置
							}
						}
					}

				算法分析：	
					时间复杂度：
						最好时间复杂度：O(n)			
						最坏时间复杂度：O(n^2)
						平均时间复杂度：O(n^2)
					空间复杂度：O(1),监视哨辅助空间r[0]
					稳定性：稳定		

				
			折半插入排序：		排序数据量很大，用折半查找法查找插入位置
				算法思想：
					第一个元素默认是已排序的
					通过二分查找找到该元素在已排序部分中的插入位置
					将当前元素插入到对应位置并移动比它大的元素
					逐步将后续元素插入到已排序部分，直到所有元素都排好序
				
				算法演示：
					89	45	54	29	90	34	68
					45	89	54	29	90	34	68			第一次排序(第二个元素45，在89中使用二分查找插入位置)
					45	54	89	29	90	34	68			第二次排序(第三个排序54，在45 89中使用二分查找插入位置)
					29	45	54	89	90	34	68			第三次排序(第四个元素29，在45 54 89中使用二分查找插入位置)
					29	45	54	89	90	34	68			第四次排序(第五个元素90，在29 45 54 89中使用二分查找插入位置)
					29	34	45	54	89	90	68			第五次排序(第六个元素34，在29 45 54 89 90中使用二分查找插入位置)
					29	34	45	54	68	89	90			第六次排序(第七个元素68，在29 34 45 54 68 89 90中使用二分查找插入位置)
					
				算法实现：
					void BInsertSort(SqList &L){	
						for(i = 2;i <= L.length;i++){					//从第2个元素开始循环，第一个默认已排序			
							L.r[0] = L.r[i];					//将待插入元素暂存到L.r[0]中
							low = 1；						//查找范围下届
							high = i - 1；						//查找范围上届
							while(low <= high){									
								mid = (low + high) / 2;				//中间位置
								if(L.r[0].key < L.r[mid].key){			//待插入元素小于mid元素
									high = mid - 1;				//目标位置在mid左边
								}else{				
									low = mid + 1;				//目标位置在mid右边
								}
							}
							for(int j = i - 1;j >= high + 1;j--){			//循环将已排序元素向后移动，腾出插入位置
								L.r[j + 1] = L.r[j]				//将元素右移
							}
							L.r[high + 1] = L.r[0];					//将监视哨值插入到正确位置
						}
					}
				
				算法分析：
					时间复杂度：
						最好时间复杂度：O(n)
						最坏时间复杂度：O(n^2)
						平均时间复杂度：O(n^2)
					空间复杂度：O(1),监视哨辅助空间O(1)
				

			希尔排序：
				算法思想：
					将整个待排序记录通过步长分割成若干个子序列，分别对若干个子序列分别进行直接插入排序
					逐步缩小步长待整个序列中的记录基本有序，在对全体记录进行依次直接插入排序

				算法演示：
					81	94	11	96	12	35	17	95	28	58	41	75	15		长度13，每2个元素进行交换，
					-	—	-	—	x	-	—	-	—	x	-	—	-
				
					35	17	11	28	12	41	75	15	96	58	81	94	95		步长：13 / 2 = 5排序完成
					-	—	x	-	—	x	-	—	x	-	—	x	-
					
					28	12	11	35	15	41	58	17	94	75	81	96	95		步长：13 / 4 = 3排序完成
					-	-	-	-	-	-	-	-	-	-	-	-	-

					11	12	15	17	28	35	41	58	75	81	94	95	96		步长：13 / 8 = 1排序完成

						补充：初始步长 = n / 2，常用步长序列：n/2，n/4，n/8，...，1
					
				算法实现：
					主程序：
						void ShellSort(SqList &L,int dlta[],int t){			
							for(k = 0;k < t;++k){
								ShellInsert(L,dlta[k]);			使用不同的增量执行分组插入排序
							}
						}
						
						解析：	int dlta[]		增量序列，控制排序时分组大小
							int t			增量序列长度
					
					一次直接插入算法：
						void ShellInsert(SqList &L,int dk){				
							for(i = dk + 1;i <=L.length;++i){							从dk + 1位置开始，逐个检查元素是否比间隔dk元素小
								if(r[i].key < r[i - dk].key){							若当前元素 < 前面间隔dk的元素
									r[0] = r[i];								将当前元素存入r[0]
									for(j = i - dk;j > 0 && (r[0].key < r[j].key);j = j - dk){		从当前位置i开始，按dk间隔查找合适插入位置
										r[j + dk] = r[j];						
									}
									r[j + dk] = r[0];							将该元素插入正确位置
								}	
							}
						}
						
						解析：	int dk			当前增量，控制每次插入排序分组大小
	
				算法分析：		
					时间复杂度：	
						最好时间复杂度：O(n)
						最坏时间复杂度：O(n^2)
						平均时间复杂度：n(log2n)^2
					空间复杂度：O(1)
					稳定性：不稳定	
		

		交换排序：
			冒泡排序：
				算法思想：
					将记录中相邻的数据两两比较，按前小后大的规则交换，依次对所有数据进行操作，直至所有数据完成排序

				算法演示：
					49	38	65	97	76	13	27	49
					
					38	49	65	76	13	27	49	97		第一次排序
					38	49	65	13	27	49	76	97		第二次排序
					38	49	13	27	49	65	76	97		第三次排序
					38	13	27	49	49	65	76	97		第四次排序
					13	27	38	49	49	65	76	97		第五次排序	
					
				算法实现：
					void BubbleSort(SqList &L){
						for(int i = 0；i < L.length;i++){				循环控制排序次数，保证元素正常排序	
							for(int j = 0;j < L.length - i;j++){			循环对相邻元素比较并交换位置
								if(L.r[j] > L.r[j + 1]){
									int temp = L.r[j];			数据交换
									L.r[j] = L.r[j + 1];
									L.r[j + 1] = temp;								
								}
							}
						}
					}

				算法分析：
					时间复杂度：
						最好时间复杂度：O(n)
						最坏时间复杂度：O(n^2)
						平均时间复杂度：O(n^2)
					空间复杂度：O(1),记录交换的暂存单元
					稳定性：稳定


			快速排序：
				算法思想：
					在待排序序列中任取一个元素为中心，左半部分数据小于等于中心元素，右半部分数据大于等于中心元素
					对左右部分分别递归重新选择中心元素排序，直到左右部分中的元素只剩一个

					中心数/基准元素选取:第一个数、最后一个数、最中间一个数、任选一个数
		
				算法演示：
					49	38	65	97	76	13	27	49	
					
					49	38	65	76	13	27	49	97		97为中心元素，将小于97的元素移动到左边
					49	38	65	13	27	49	76	97		递归，76为中心元素，将小于76的元素移动到左边
					49	38	13	27	49	65	76	97		递归，65为中心元素，将小于65的元素移动到左边
					13	49	38	27	49	65	76	97		递归，13为中心元素，将大于13的元素移动到右边
					13	27	38	49	49	65	76	97		递归，以38为中心元素，将小于38的元素移动到左边，大于38的元素移动到右边
					13	27	38	49	49	65	76	97		递归，以49为中心元素，将小于49的元素移动到左边，大于49的元素移动到右边
					
				算法实现：
					快速排序：	
						void QuickSort(SqList &L,int low,int high){				low/high：当前处理部分数据的左右边界
							int mid;
							if(low < high){
								mid = Partition(L,low,high);				返回中心点元素位置
								QuickSort(L,low,mid - 1);				对左半部分进行排序
								QuickSort(L,low,mid + 1);				对右半部分进行排序
							}
						}

					找中心点位置：
						int Partition(SqList &L,int low,int high){						
							L.r[0] = L.r[low];										
							pivotkey = L.r[low].key;					将数组第一个元素L.r[low]作为基准元素	
							while(low < high){						
								while(low < high && L.r[high].key >= pivotekey){	
									--high;						当high指向元素大于等于基准元素时，high指针不断向左移动
									L.r[low] = L.r[high];				右侧high值缩减到比基准元素小，替换基准元素
								}
								while(low < high && L.r[low].key <= pivotekey){		
									++low;						当low指向元素小于等于基准元素时，low指针不断向右移动
									L.r[high] = L.r[low];				左侧low值递增到比基准元素大，替换基准元素
								}
							}
							L.r[low] = L.r[0];						将原先作为基准元素的L.r[0]放到正确位置
							return low;							返回当前基准元素位置
						}
				
				算法分析：
					时间复杂度：
						最好时间复杂度：O(nlogn)
						最坏时间复杂度：O(n^2)
						平均时间复杂度：O(nlogn)
					空间复杂度：O(logn)
					稳定性：不稳定


		选择排序：
			简单选择排序：
				基本思想：每一趟在待排序序列中选取最大或最小的关键字记录，直到全部元素排序完毕
				
				算法思想：
					第一次：(n - 1)次关键字比较，从n个记录中选出关键字最小的记录与第一个记录交换
					第二次：(n - 2)次关键字比较，从(n - 1)个记录中选出关键字最小的记录与第二个记录交换
					第i次：(n - i)次关键字比较，从(n - i + 1)个记录中选出关键字最小的记录与第i个记录交换
					直到全部元素排序完成

				算法演示：
					49	39	65	97	76	13	27	69
					
					13	39	65	97	76	49	27	69		8个记录中，13为最小值，与第一个记录交换
					13	27	65	97	76	49	39	69		7个记录中，27为最小值，与第二个记录交换
					13	27	39	97	76	49	65	69		6个记录中，39为最小值，与第三个记录交换
					13	27	39	49	76	97	65	69		5个记录中，49为最小值，与第四个记录交换
					13	27	39	49	65	97	76	69		4个记录中，65为最小值，与第五个记录交换
					13	27	39	49	65	69	76	97		3个记录中，69为最小值，与第六个记录交换
														元素排序完毕						
				
				算法实现：
					void SelectSort(SqList &L){
						for (int i = 0; i < L.length - 1; i++) {  			遍历待排序序列
        						int k = i;  						假设当前元素是最小值
        						for (int j = i + 1; j < L.length; j++) {  		循环待排序的序列
            							if (L.r[j].key < L.r[k].key) {			
                							k = j;  				待排序序列中有比最小值还小的值，替换
            							}
        						}
        						if (k != i) {  						若当前元素不是最小值
            							L.r[i]←→L.r[k];					交换数组L.r[i]和L.r[k]的值
        						}
    						}
					}

				算法分析：
					时间复杂度：O(n^2)
					空间复杂度：O(1)
					稳定性：不稳定

			树形选择排序/锦标赛排序(了解):
				基本思想：
					将n个参赛选手视为完全二叉树的叶子结点，对n个叶子结点两两比较，关键字较小者胜出，胜出的结点在兄弟结点之间再两两比较，直至产生第一名
					从根结点到叶子结点的路径，每一层胜出的分支结点，直至所有选手名次排定
										
				算法思想：
					从最底层叶子结点开始，逐层比较各层兄弟结点，选出最小关键字上升为双亲结点，直至根结点
					从根结点(最小值)到叶子结点按照关键字最大值依次排序
					若输出结点总数小于初始树的叶子结点数，重新选择排序
					
				算法演示：
							 13			排序：最小堆(根结点是最小值)/最大堆(根结点是最大值)
						    ↙	      ↘
						39		 13
					      ↙     ↘	      ↙    ↘
					   39	     65	    13	      27
					 ↙   ↘   ↙  ↘  ↙ ↘    ↙	↘
					49   39	  65   97 76  13   27	69		
				
			堆排序：
				基本概念：
					堆：n个元素的序列{k1,k2,...,kn},ki满足以下关系：
						ki <= k2i		ki >= k2i
						ki <= k(2i+1)  	或	ki >= k(2i+1)
						小顶堆			大顶堆
				
					大顶堆/最大堆：每个结点值都大于等于其左右孩子结点的值，根结点是整个堆中最大的元素
					小顶堆/最小堆：每个结点值都小于等于其左右孩子结点的值，根结点是整个堆中最小的元素

				基本思想：
					n个待排序记录序列构造堆，选出堆中最小值/最大值(堆顶)，移除
					在(n-1)个待排序记录序列构造堆，选出堆中最小值/最大值(堆顶)，移除
					依次类推，直至堆中只有一个记录为止

				堆排序实现：
					排序堆思路：
						堆建立(将无序序列建成堆)：
							将序号n/2，n/2 - 1，...，1的结点(最后一个非叶子结点)为根的子树调整为堆							

						堆调整(输出堆顶，将剩余元素建成堆)：
							1.输出堆顶元素，用最后一个结点(编号最大)代替根结点		
							2.将根结点值与左右子树的根结点值进行比较，并与其中较小者/较大者进行交换
							3.依次类推，直至叶子结点
					
					完整堆排序(了解)：
						public static void heapSort(int[] arr){
							int start = (arr.length - 1) / 2;			从最后一个非叶子结点n/2开始调整为堆
							for(int i = start;i >= 0;i--){
								maxHeap(arr,arr.length,i);
							}
							for(int i = arr.length - 1;i > 0;i--){			
								int temp = arr[0];
								arr[0] = arr[i];
								arr[i] = temp;			
							}
						}
						
						public  static  void  maxHeap(int[] arr, int size, int index) {
        
        						int leftNode = 2 * index + 1;					左子节点
        						int rightNode = 2 * index + 2;					右子节点
       							int max = index; 						先设当前为最大节点
       							if (leftNode < size && arr[leftNode] > arr[max]) { 		找最大节点
           							max = leftNode;
        						}
        						if (rightNode < size && arr[rightNode] > arr[max]) {
            							max = rightNode;
        						}
        						if (max != index) {						交换位置，可能会破坏之前排好的堆，所以之间排好的堆需要重新调整
            							int temp = arr[index];
            							arr[index] = arr[max];
            							arr[max] = temp;
            							maxHeap(arr, size, max);
        						}
        						System.out.println(Arrays.toString(arr));				打印每次排序后的结果 
    						}

				算法分析：
					时间复杂度：O(nlogn)
					空间复杂度：O(1)
					稳定性：不稳定
			
		归并排序：
			基本思想：将两个或两个以上的有序子序列"归并"为一个有序序列

			归并排序按所合并表个数分为：二路归并排序 + 多路归并排序	
					
			二路归并排序：
				算法思想：
					分解：将待排序序列划分为两个长度相当的子序列
					解决：若子序列长度大于1，对子序列执行一次归并排序
					合并：将两个已排序的子数组合并成一个有序序列

				算法演示：
					(49)	(39)	(65)	(97)	(76)	(13)	(27)	(69)
					  ↘ 	↙	  ↘	↙	  ↘	↙	  ↘	↙
					  (39 49)	  (65 97)	  (13 76)	  (27 69)
						↘	    ↙			↘	  ↙
					       (39 49 65 97)		       (13 27 69 76)
							↘			↙
							(13 27 39 49 65 69 76 97)
				
				算法实现(过于复杂略)

				算法分析：
					时间复杂度：O(nlogn)
					空间复杂度：O(n)
					稳定性：稳定

		基数排序/桶排序/箱排序：	
			箱排序：设置若干个箱子，将关键字为k的记录放入第k个箱子，对桶中元素进行排序，再将所有桶中元素按顺序合并		

			基本思想：将数字分成若干位(由低位到高位)，使用桶排序对每一位数进行排序，通过多次排序获得有序的数组
				数字均由0-9十个数字组成，只需设置十个箱子，相继按个、十、百进行排序

			算法演示：
				614	738	921	485	637	101	215	530	790	306
				
				箱子：
					0	1	2	3	4	5	6	7	8	9
					530	921			614	485	306	637	738		按个位排序
					790	101				215						
			
					按个位排序：
						530	790	921	101	614	485	215	306	637	738
					
					----------------------------------------------------------------------------------------
					
					101	614	921	530					485	790	按十位排序
					306	215		637
								738

					按十位排序：
						101	306	614	215	921	530	637	738	485	790

					-----------------------------------------------------------------------------------------
					
						101	215	306	485	530	614	738		921	按百位排序
											637	790

					按百位排序：
						101	215	306	485	530	614	637	738	790	921
						
						注意：按照百位排序时数字已排序完成

			算法实现(过于复杂略)
				
			算法分析：	
				时间复杂度：O(d*(n + k))			n：待排序元素个数		d：数字位数	k：基数(桶数量，十进制数，k = 10)
				空间复杂度：O(n + k)
				稳定性：稳定

























		
